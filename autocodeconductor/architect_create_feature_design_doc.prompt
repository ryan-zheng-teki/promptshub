You are a python software architect. You are given one feature requirement and system design 
documentation between `$start$` and `$end$` tokens in the [Documentation] section.

You will address the user request in the `[Request]` section.

Think methodically step by step and reason comprehensively.

[Documentation]
$start$
$end$

[Request]




Version 2: Create feature code architecture documentation.
You are a python software architect. You are given one feature requirement documentation in the `[Requirement]` section.

Your task is to create one feature code design documentation based on the requirement.

### Criterias
- The final code design documentation should follow the format defined in the `[Template]` section. You can refer to the `[Example]` section for reference.
- Think about what design patterns can be used.
- Have good naming for designed codes and APIs.
- 

Think methodically step by step and reason comprehensively for this task.

You are a Python software architect. Based on the requirements provided in the `[Requirement]` section, your task is to draft a feature code design documentation.

### Criteria:
- Adhere to the format in the `[Template]` section. For guidance, refer to the `[Example]` section.
- Consider relevant design patterns.
- Ensure clear and descriptive naming for codes and APIs.

Think step by step meticulously and reason comprehensively to address this task.


You are a Python software architect. Your task is to draft a feature code design documentation, based on the requirements provided in the `[Requirement]` 

### Approach:
1. **Understand the Requirement**: Go through the `[Requirement]` section carefully. Identify the main features and functionalities expected. 
2. Understand the existing feature code design in the `[ExistingFeatureCodeDesign]` section if given.  
3. **Seek Clarifications**: If there's anything unclear or ambiguous, ask questions. Do not proceed until you have a full understanding.
4. **Refer to the Template**: Check the `[Template]` section to understand the format and structure of the design documentation.
5. **Design Patterns**: Consider which design patterns, if any, would be most relevant and effective for the described feature.
6. **Draft the Documentation**: Begin writing the design documentation, keeping clarity and coherence in mind.

### Criteria:
- **Clarity**: Component should not only list APIs, but also attributes. So that implementation-clear subtasks can be created based code design.  
- **Adherence to Template**: The design should follow the structure provided in the `[Template]` section.
- **Relevant Design Patterns**: Ensure that python best practice design patterns are considered for such feature. 
- **Descriptive Naming**: Codes, APIs, functions, etc., should have clear and descriptive names and description, making it easy to understand their purpose.
- Classes in UML diagram should detailed to attributes and APIs.

Follow the steps defined in the 'Approach'. Ensure meticulous thinking and comprehensive reasoning for each step.



You are a Python software architect. Your task is update one existing feature code design documentation, based on the provided updated requirement documentation in the  `[Requirement]` section.

### Approach:
Follow these steps to complete your task:

1. **Understand the Requirement**: Go through the `[Requirement]` section carefully. Identify the main features and functionalities expected.
2. **Understand the Existing Feature Code Design**: If given, go through the `[ExistingFeatureCodeDesign]` section to understand how the current code design works and analyse step by step whether current code design achieves all requirements.
3. **Seek Clarifications**: If there's anything unclear or ambiguous in the requirement or the existing code design, ask questions. Do not proceed until you have a full understanding of the problem and the solution.
4. **Apply Design Patterns**: Consider which design patterns, if any, would be most relevant and effective for the described feature. Use Python best practices and standards when applying design patterns.
5. **Draft the Documentation**: Begin writing the design documentation, keeping clarity and coherence in mind. Use UML diagrams to illustrate your design, including both APIs and attributes for each class. Use clear and descriptive names and descriptions for your codes, APIs, functions, etc.

### Criteria:
Your design documentation will be evaluated based on these criteria:

- **Clarity**: Your UML diagrams must include both APIs and attributes for each class, making it easy to create implementation tasks based on your design.
- **Adherence to Template**: Your design must follow the format provided in the `[Template]` section.
- **Relevant Design Patterns**: Your design must apply Python best practices and standards when using design patterns.
- **Descriptive Naming**: Your codes, APIs, functions, etc., must have clear and descriptive names and descriptions, making it easy to understand their purpose.


Follow the steps defined in the 'Approach'. Ensure meticulous thinking and comprehensive reasoning for each step.


[Requirement]
### Enhanced Automated Coding Workflow with Versioned Prompts for Comparative Analysis

#### 1. Story/Feature Description:

1.1. **Background**: 
The Automated Coding Workflow, designed to interact with Large Language Models (LLMs) for automating coding tasks, requires an upgrade. The inherent variability in LLM responses based on prompt nuances has necessitated versioned prompts for each step. The aim encompasses flexibility and comparative analysis between different versions to determine the most effective prompt.

1.2. **User Persona**: 
Software Developer or AI System:
  - Engages with the Automated Coding Workflow to utilize LLM capabilities.
  - Aspires to contrast LLM responses across different prompt versions to pinpoint the optimal prompt.
  - Desires a streamlined interface to manage, select, and juxtapose various prompt versions.

1.3. **User Journey**: 
Upon interacting with a specific step in the Automated Coding Workflow, a user can modify a prompt and save it as a distinct version. They have the liberty to manually set any version as the current effective prompt. A dropdown facilitates switching between versions, enabling them to fetch LLM responses for each. A comparative analysis follows to discern the most suitable prompt.

#### 2. Requirements:

2.1. **Functional Requirements**:

- **Step-Specific Default and Effective Prompts**:
   - Every step within the Automated Coding Workflow boasts a distinct default prompt, intrinsic to the step's code.
   - On the step's inception, if the database lacks prompts specific to that step, the default prompt initializes the database. This primary prompt is designated as v1 and is set as the immediate current effective prompt by default.
   - Users retain the autonomy to manually select any archived version as the current effective prompt for a step.

- **Dynamic Initialization of Versioned Prompts**:
   - At the commencement of a step, the system retrieves the current effective prompt from the database.
   - If the database lacks a version for a step, it's initialized using the step's inherent default prompt.

- **Decoupling Static Prompt Template**:
   - Extinguish the static prompt template from `BaseStep`.
   - Dynamically derive the prompt content from the database based on the version or extract it from the step's default if it's absent in the database.

- **Prompt Version Management**:
   - Allow the creation of a new prompt version for a step when the existing prompt undergoes alterations.
   - Preserve a maximum of 4 prompt versions for every step in the database.
   - Enlist all versions within a dropdown for user-centric selection during engagements.
   - Introducing a new version that surpasses the 4-version threshold leads to the irrevocable deletion of the oldest version.

- **Comparative Analysis**:
   - Simplify the transition between diverse prompt versions for execution and procuring LLM feedback.
   - Ponder over introducing a side-by-side comparison utility in future endeavors, potentially with an emphasis on highlighting variances between chosen versions.

- **Viewing Past Versions**:
   - Empower users to peruse the content of bygone prompt versions for reference.
   - Guarantee facile access and intuitive traversal to previous versions.

- **Database Management**:
   - Symbolize versions using elementary incremented numerals (e.g., v1, v2, etc.).
   - Archive the creation/modification timestamp for every version.

- **User Interface**:
   - Infuse a dropdown mechanism within the user interface to champion prompt version selection.
   - Accentuate clarity in version differentiation and expedite the comparative analysis trajectory.



[ExistingFeatureCodeDesign]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
The enhancement integrates a versioning mechanism for prompts used in each workflow step. By introducing the `PromptVersioningMixin`, the original `BaseStep` structure and workflow remain largely unaffected. However, they now acquire versioning functionalities that store, manage, and refine versioned prompts in a database. The Repository Pattern from previous features is leveraged for database interactions.

#### 2. Component Modifications:

2.1. **New Components**:

- **PromptVersioningMixin**: 
  - *Purpose*: A mixin class offering versioning capabilities with integrated database interactions.
  - *Attributes*: 
    - `current_effective_version: int`: Represents the version number of the current effective prompt.
    - `default_prompt: str`: The default prompt intrinsic to the step's code.
  - *Methods*: 
    - `add_version(prompt: str)`: Creates and stores a new version of the prompt. If the number of versions surpasses the limit (4), it deletes the oldest version.
    - `get_version(version_no: int)`: Retrieves the content of a specified prompt version.
    - `set_current_effective_version(version_no: int)`: Sets a specific version as the current effective prompt.
    - `get_current_effective_version()`: Fetches the content of the current effective prompt.
    - `load_latest_version()`: Retrieves the content of the latest created prompt version.

- **VersionedPrompt**:
  - *Purpose*: Represents the state of a prompt at a particular version in-memory.
  - *Attributes*: 
    - `version_no: int`: The version number.
    - `prompt_content: str`: The content of the prompt for that version.

- **PromptVersionModel (extends BaseModel)**:
  - *Purpose*: Represents the database model for storing versioned prompts.
  - *Attributes*: 
    - `step_id: String`: Identifier for the step.
    - `version_no: Integer`: Version number.
    - `prompt_content: Text`: Content of the prompt.
    - `is_current_effective: Boolean`: Indicates if this version is the current effective prompt.
    - `created_at: DateTime`: Timestamp for creation/modification.

- **PromptVersionRepository (extends BaseRepository)**:
  - *Purpose*: Offers CRUD operations for `PromptVersionModel` and manages version-specific operations.
  - *Methods*: 
    - `create_version(prompt_version: PromptVersionModel)`: Stores a new prompt version.
    - `get_version(step_id: String, version_no: int)`: Fetches a specific version of a prompt.
    - `get_current_effective_version(step_id: String)`: Retrieves the current effective prompt for a step.
    - `get_latest_created_version(step_id: String)`: Retrieves the most recently created prompt version.
    - `delete_version(step_id: String, version_no: int)`: Deletes a specific version.
    - `delete_oldest_version(step_id: String)`: Deletes the oldest version when the limit is surpassed.

2.2. **Updated Components**:

- **BaseStep**:
  - *Modification*: Extend from `PromptVersioningMixin`.
  - *Purpose*: Inherits versioning capabilities with database integration. The static prompt template from `BaseStep` is removed, and prompts are dynamically derived based on the version.

2.3. **Unchanged Components**:

- **BaseModel**: 
  - *Description*: The foundational model class for database entities.
  
- **BaseRepository**: 
  - *Description*: Provides generic CRUD operations.

#### 3. Interactions:

3.1. **Component Interactions**:

- Steps augmented with `PromptVersioningMixin` will possess versioning capabilities with database operations.
- `PromptVersioningMixin` will interface with `PromptVersionRepository` for database interactions.

#### 4. External Dependencies: 

- **SQLAlchemy**: ORM tool facilitating database operations.
- **Alembic**: For database migration and versioning.

#### 5. UML Diagram:

@startuml

package "Versioned Prompts Structure" {

class "PromptVersioningMixin (New)" {
    + add_version(prompt: str)
    + get_version(version_no: int): str
    + set_current_effective_version(version_no: int)
    + get_current_effective_version(): str
    + load_latest_version(): str
    + default_prompt: str
    + current_effective_version: int
}

class "VersionedPrompt (New)" {
    + version_no
    + prompt_content
}

class "PromptVersionModel (New, extends BaseModel)" {
    + step_id: String
    + version_no: Integer
    + prompt_content: Text
    + is_current_effective: Boolean
    + created_at: DateTime
}

class "PromptVersionRepository (New, extends BaseRepository)" {
    + create_version(prompt_version: PromptVersionModel): PromptVersionModel
    + get_version(step_id: String, version_no: int): PromptVersionModel
    + get_current_effective_version(step_id: String): PromptVersionModel
    + get_latest_created_version(step_id: String): PromptVersionModel
    + delete_version(step_id: String, version_no: int)
    + delete_oldest_version(step_id: String)
}

"PromptVersioningMixin (New)" o-- "VersionedPrompt (New)"
"PromptVersioningMixin (New)" o-- "PromptVersionRepository (New)"
"PromptVersionModel (New)" --|> "BaseModel"
"PromptVersionRepository (New)" --|> "BaseRepository"


}

@enduml












Version 2: update the code design based on the given code. (I have a lot of code)
Thank you for generating the code design. Now i have the following questions, please think 
meticulously and reason comprehensively based on the best practices in the programming 
language. 

User Questions:
1. 