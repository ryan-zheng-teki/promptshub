Version 1: This prompts works for both GPT3.5 and GPT4. But GPT4 works like insanely good.

You are a senior Python software engineer. You have been given a Python code file provided in the `[Code]` section. Your task is to create integration for the given Python code file.

[Criteria]
- Ensure that the test cases follow pytest best practices.
- Use best practice to create test file paths. Here is a sample in the current project's 
  demonstrating test file path for both unit test and integration test:
    src
        semantic_code
                embedding
                    openai_embedding_creator.py
    tests
        unit_tests
            semantic_code
                embedding
                    test_openai_embedding_creator.py
        integration_tests
            semantic_code
                index
                    test_index_service_integration.py

- Ensure that the tests provide full coverage of the code.
- Use behavior-driven naming conventions for the test cases.

[Available Commands]
- execute_bash: Use this command to execute bash commands as needed.
- write_file: Use this command to write the test cases to a file.

Think and reason yourself in high detail to address the task.


[Code]
file path: src/semantic_code/embedding/openai_embedding_creator.py
```

```


Version 2: Contains the details of steps


As the best python developer on earth, you are given a task situated between `$start$` and `$end` tokens in the `[Requirement]` section.

[Criterias]
- Follow python coding best practices
- Follow pytest best practices when writting tests.
- Ensure that the tests provide full coverage of the code.
- Use behavior-driven naming conventions for the test cases
- Use best practices to create test file path. Here is a sample best practice to 
  put the test file for the source file.
    src
        semantic_code
                embedding
                    openai_embedding_creator.py
    tests
        unit_tests
            semantic_code
                embedding
                    test_openai_embedding_creator.py
        integration_tests
            semantic_code
                index
                    test_index_service_integration.py
- Include file paths accompanied with complete code in code block for the newly created or updated files.

Think step by step, and reason comprehensively to address the task.

[Requirement]
$start$
I have the following test method defined.
```
def test_prompt_template_to_dict():
    """
    Given a PromptTemplate,
    When its to_dict method is called,
    Then it should return a dictionary representation of the template.
    """
    variable = PromptTemplateVariable(name="requirement", 
                                      source=PromptTemplateVariable.SOURCE_USER_INPUT, 
                                      allow_code_context_building=True, 
                                      allow_llm_refinement=True)

    template_str = "This is a template with {requirement}"
    prompt_template = PromptTemplate(template=template_str, variables=[variable])

    expected_dict = {
        "template": template_str,
        "variables": [variable.to_dict()]
    }

    assert prompt_template.to_dict() == expected_dict

```
But i want the expected_dict to be a string and more realistic. 
Here is the prompt_template_variable.py
```
"""
src/prompt/prompt_template_variable.py

This module contains the PromptTemplateVariable class, which represents a variable within a prompt template. 
Each variable can have a source (e.g., dynamically replaced based on the project or provided by user input) 
and can have capabilities like code context building and LLM refinement.

PromptTemplateVariable class features:
- The variable name.
- The source of the variable: DYNAMIC or USER_INPUT.
- Flags to indicate if the variable allows code context building or LLM refinement.
- A method to convert the variable to a dictionary representation for frontend communication.
- Methods to set and retrieve the value of the variable.
"""

class PromptTemplateVariable:
    SOURCE_DYNAMIC = "DYNAMIC"
    SOURCE_USER_INPUT = "USER_INPUT"

    def __init__(self, name: str, source: str, allow_code_context_building: bool = False, allow_llm_refinement: bool = False):
        self.name = name
        self.source = source
        self.allow_code_context_building = allow_code_context_building
        self.allow_llm_refinement = allow_llm_refinement
        self._value = None  # Internal value storage

    def set_value(self, value: str) -> None:
        """
        Set the value for this variable.

        Args:
            value (str): The value to set.
        """
        self._value = value

    def get_value(self) -> str:
        """
        Retrieve the value for this variable.

        Returns:
            str: The value of this variable.
        
        Raises:
            ValueError: If the value is not set.
        """
        if self._value is None:
            raise ValueError(f"Value for variable '{self.name}' is not set.")
        return self._value

    def to_dict(self) -> dict:
        """
        Converts the PromptTemplateVariable instance to a dictionary representation.

        Returns:
            dict: Dictionary representation of the PromptTemplateVariable instance.
        """
        return {
            "name": self.name,
            "source": self.source,
            "allow_code_context_building": self.allow_code_context_building,
            "allow_llm_refinement": self.allow_llm_refinement
        }

```
$end