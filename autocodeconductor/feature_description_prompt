You are an expert in refining and enhancing task descriptions to ensure clarity, conciseness, effectiveness, and optimal structure. Your task is to analyze the provided task description enclosed with three backticks, improve it based on your domain knowledge, and ensure the revised description better conveys its purpose while maintaining a professional and explicit writing style.

Adjust the wording, add additional content or requirements as needed, drawing from your knowledge of similar features, and create a logically coherent and semantically organized output without redundancy.

You should incorporate all information, including codes, from the original task description in the output, as it will be stored in a third-party platform for later reference. 

For instance, if you recognize file paths and codes in the task description, move the codes to the 'Code References' section under the respective path, description, and code subsections. Identify constraints such as programming languages, frameworks etc from the task description and include them in the 'Constraints' section.

Use the following format for the output:

```Title: [Title of the task]

Objective:
- [Objective of the task]

Background:
- [Background information related to the task]

Requirements:
- [List of requirements for the task]

Constraints:
- [List of constraints or limitations for the task]

Code References: (if codes exist in the task description)
- path
- description
- code (complete code for the file given in the task description)
```

Provide the complete output in a copiable preformatted text block.

Task description:

```
we have implemented llm_workflow_core library which contains a workflow registry and workflow manager. 

To know how to use it, we have a test class created.
import pytest
from llm_workflow_core.registry.workflow_registry import WorkflowRegistry
from llm_workflow_core.manager.workflow_manager import WorkflowManager
from automated_coding_workflow.automated_coding_workflow import AutomatedCodingWorkflow

@pytest.fixture
def workflow_registry():
    registry = WorkflowRegistry()
    # When: Registering the AutomatedCodingWorkflow
    workflow_package = "automated_coding_workflow"

    # When: Loading the workflow using the WorkflowRegistry
    config = {"workflows": {"enabled_workflows": [workflow_package]}}
    registry.load_enabled_workflows(config)
    return registry


@pytest.fixture
def workflow_manager(workflow_registry):
    return WorkflowManager(workflow_registry)

def test_given_valid_workflow_name_when_initializing_workflow_then_workflow_instance_is_created_and_stages_are_executed_correctly(workflow_manager: WorkflowManager):
    # Initialize the workflow
    workflow_id = workflow_manager.initialize_workflow("automated_coding_workflow")
    assert workflow_id is not None

    # Execute the stages in the correct order
    requirement_result = workflow_manager.execute_stage(workflow_id, "requirement")

    requirement_refine_result = workflow_manager.execute_stage(workflow_id, "refine")

    design_result = workflow_manager.execute_stage(workflow_id, "design")

    test_generation_result = workflow_manager.execute_stage(workflow_id, "test_generation")

    implementation_result = workflow_manager.execute_stage(workflow_id, "implementation")

    testing_result = workflow_manager.execute_stage(workflow_id, "testing")


Now we need to integrate this to our server application which use app.py as the entery.
"""
app.py: The main entry point for a Python application with three modes of operation: command line, gRPC server mode, and GraphQL server mode.

The script allows users to:
- Interact with a chat system through PuppeteerLLMIntegration in command line mode.
- Run a gRPC server for AutomatedCodingWorkflowService in gRPC server mode.
- Run a FastAPI server with GraphQL endpoints using the Strawberry GraphQL library in GraphQL server mode.

The mode, configuration file, server hostname, and port are specified through command line arguments. The script parses these arguments and executes the appropriate mode function with the necessary parameters.

Usage:
- For command line mode: python app.py --mode commandline
- For gRPC server mode: python app.py --mode grpcserver --host 127.0.0.1 --port 50051
- For GraphQL server mode: python app.py --mode graphqlserver --host 127.0.0.1 --port 8000
"""

import argparse
import os
import sys
import logging

from pathlib import Path
import sys

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from src.startup_mode.cli_mode import command_line_mode
from src.startup_mode.grpc_server_mode import grpc_server_mode
from src.startup_mode.graphql_server_mode import graphql_server_mode
from src.config.config import config

# Set up logging
logging.basicConfig(filename='app.log', level=logging.INFO)

def parse_command_line_arguments():
    parser = argparse.ArgumentParser(description='Python app with three modes: command line, gRPC server mode, and GraphQL server mode.')
    parser.add_argument('--mode', choices=['commandline', 'grpcserver', 'graphqlserver'], help='Select the mode to run the app', required=True)
    parser.add_argument('--host', help='Server hostname', default='127.0.0.1')
    parser.add_argument('--port', type=int, help='Server port', default=8000)

    return parser.parse_args()

def main():
    args = parse_command_line_arguments()
    
    if args.mode == 'commandline':
        command_line_mode(config)
    elif args.mode == 'grpcserver':
        grpc_server_mode(config, args.host, args.port)
    elif args.mode == 'graphqlserver':
        graphql_server_mode(config, args.host, args.port)
    else:
        print("Invalid mode selected.")
        sys.exit(1)

if __name__ == "__main__":
    main()


The task is to create a  workflow registry, and manager during server startup. The created registry 
and manager needs to be globally accessible. So you need to do design based on current app.


```

Can you combine this requirement with the Task Description from the "refining and enhancing task descriptions" task, and reperform the "refining and enhancing task descriptions" task?


thank you for generating the optimized prompts. Now please execute the task defined by the optimized prompt







Title: Integrate Workflow Registry and Manager into the Server Application

Objective:
- Create and integrate a global Workflow Registry and Manager into the server application during server startup.

Background:
- The llm_workflow_core library has been implemented, which contains a workflow registry and workflow manager. A test class has been created to demonstrate how to use it.

Requirements:
- Update the server application's startup process to create a global Workflow Registry and Manager during initialization.
- Ensure that the created registry and manager are globally accessible.
- Design the integration based on the current app structure.

Constraints:
- The server application uses app.py as the main entry point.
- The application has three modes of operation: command line, gRPC server mode, and GraphQL server mode.

Code References:
- path: llm_workflow_core/test/test_workflow.py
  description: Test class for llm_workflow_core library usage
  code: (The complete code block containing pytest.fixture and test_given_valid_workflow_name_when_initializing_workflow_then_workflow_instance_is_created_and_stages_are_executed_correctly function)

- path: app.py
  description: The main entry point for the server application with three modes of operation
  code: (The complete code block from the task description containing import statements, parse_command_line_arguments function, and main function)
