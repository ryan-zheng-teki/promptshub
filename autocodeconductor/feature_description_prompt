You are an expert in refining and enhancing task descriptions to ensure clarity, conciseness, and effectiveness. Your task is to analyze the provided task description, improve it based on your domain knowledge, and ensure the revised description better conveys its purpose while maintaining a professional and explicit writing style. Modify the wording, add additional content as needed, and follow a logical semantic order without redundancy. 

Include all the information including codes from the original task description in the output, as it will be neccessary for the next task. You should move the Python codes provided in the feature description to the 'Code References' section under the respective path, description, and code subsections. Please don't omit any code snippet

Present the output in a copiable preformatted text block.

Use the following format for the output:

Title: [Title of the task]

Objective:
- [Objective of the task]

Background:
- [Background information related to the task]

Requirements:
- [List of requirements for the task]

Constraints:
- [List of constraints or limitations for the task]

Code References:
- path
- description
- code(complete code for file given in the task description)

Task Description:
'''

We have implemented src/communication/puppeteer_output.py
"""
puppeteer_output.py: Provides a PuppeteerOutput class to interact with a chat system using Puppeteer.

The PuppeteerOutput class enables interaction with chat systems that require headless browser interactions. It allows users to send messages, copy chatbot responses to the clipboard, and process a list of input messages.

Features:
- Initialize a PuppeteerOutput instance with a configuration file containing relevant CSS selectors for the chat system.
- Connect to a running browser instance using the Puppeteer library and find the desired chat page.
- Iterate through a list of input messages, sending them one by one to the chat system.
- After sending a message, the program asks the user if they want to copy the chatbot's response to the clipboard.
- If the user agrees, the response is copied to the clipboard and displayed to the user.
- The program waits for the chat system's response to be complete before moving on to the next message.
"""

class PuppeteerOutput:
        """
    PuppeteerChat class enables interaction with chat systems that require headless browser interactions.
    """
    def __init__(self, config: Config):

    async def process_chat_messages(self, input_messages):
    """
    Process input messages using Puppeteer, send them to the chat system, and handle clipboard interactions.
    """

But actually is actually integrating GPT LLM. The way it integrate with is sending the message to website textbox and copy the content back. instead of calling the GPT API and get the response from the API. So its actually one way of doing LLM integration, giving the input and get the response from the LLM integration.

In our src/workflow/automated_coding_workflow.py
"""
This module contains the AutomatedCodingWorkflow class that represents
the main entry point for running the automated coding workflow.
"""
class AutomatedCodingWorkflow:
    """
    A class to represent a fully automated coding workflow.
    """

    def __init__(self):
        """
        Initialize the workflow instance and set the initial stage.
        """
        self.stages = list(WORKFLOW_CONFIG.keys())
        self.output_system = PuppeteerOutput()
In the AutomatedCodingWorkflow we use PuppeteerOutput like the code shows above.

The task is to refactor the codes to better reflect the funtionality of PupperteerOutput.  Please also design a solution to support multiple LLM integrations. Since we want to have multiple LLM integrations, which LLM integration will be used for AutomatedCodingWorkflow should be cofigurable. 
It should be a property in the configuration file config.toml.

our current src/config.toml looks like this
[browser]
url = "your_browser_url"

[domain]
value = "your_domain"

[selectors]
textarea_selector = "textarea[placeholder=\"Send a message...\"]"
copy_button_selector = "div.flex.flex-col.items-center > div:nth-last-child(2) button.flex.ml-auto.gap-2"
response_container_selector = "div.flex.flex-col.items-center > div:nth-last-child(2)"



Constraints:
1. Adhere to SOLID design princiles
2. we already have src/app.py which initialized FastAPI app  
'''








