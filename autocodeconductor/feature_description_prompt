You are an expert in refining and enhancing task descriptions to ensure clarity, conciseness, effectiveness, and optimal structure. Your task is to analyze the provided task description enclosed with three backticks, improve it based on your domain knowledge, and ensure the revised description better conveys its purpose while maintaining a professional and explicit writing style.

Adjust the wording, add additional content or requirements as needed, drawing from your knowledge of similar features, and create a logically coherent and semantically organized output without redundancy.

You should incorporate all information, including codes, from the original task description in the output, as it will be stored in a third-party platform for later reference. 

For instance, if you recognize file paths and codes in the task description, move the codes to the 'Code References' section under the respective path, description, and code subsections. Identify constraints such as programming languages, frameworks etc from the task description and include them in the 'Constraints' section.

Use the following format for the output:

```Title: [Title of the task]

Objective:
- [Objective of the task]

Background:
- [Background information related to the task]

Requirements:
- [List of requirements for the task]

Constraints:
- [List of constraints or limitations for the task]

Code References: (if codes exist in the task description)
- path
- description
- code (complete code for the file given in the task description)
```

Provide the complete output in a copiable preformatted text block.

Task description:

```
previously we have implemented half finished configurable workflow design. Here are the codes

llm_workflow_core/registry/workflow_registry.py
"""
workflow_registry.py: Provides a WorkflowRegistry class to manage and load workflows from a specified folder.

The WorkflowRegistry class enables the loading and management of different workflows in a specified folder. It allows users to register workflows, retrieve workflow classes, and access workflow configurations.

Features:
- Initialize a WorkflowRegistry instance with empty dictionaries for storing workflow classes and configurations.
- Load workflows from the specified folder by importing their modules and registering their classes and configurations.
- Register a workflow with a given name, class, and configuration.
- Retrieve the workflow class for a given name.
- Retrieve the workflow configuration for a given name.
"""

from typing import Dict
from importlib import import_module
from pathlib import Path

class WorkflowRegistry:
    """
    A registry for managing and loading workflows from a specified folder.
    """

    def __init__(self):
        """
        Initialize the registry with empty dictionaries for workflows and configurations.
        """
        self.workflows: Dict[str, type] = {}
        self.configs: Dict[str, dict] = {}

    def load_installed_workflows(self, folder: str = "installed_workflows"):
        """
        Load workflows from the specified folder by importing their modules and registering
        their classes and configurations.

        :param folder: The folder containing installed workflows.
        """
        installed_workflows_folder = Path(folder)
        for workflow in installed_workflows_folder.iterdir():
            if not workflow.is_dir():
                continue

            module_path = f"{workflow.parent.name}.{workflow.name}.workflow"
            try:
                module = import_module(module_path)
                workflow_class = getattr(module, "Workflow")
                workflow_config = getattr(module, "WORKFLOW_CONFIG")
                self.register_workflow(workflow.name, workflow_class, workflow_config)
            except (ModuleNotFoundError, AttributeError) as e:
                print(f"Error loading workflow from {module_path}: {e}")

    def register_workflow(self, name: str, workflow_class: type, config: dict):
        """
        Register a workflow with the given name, class, and configuration.

        :param name: The name of the workflow.
        :param workflow_class: The workflow class.
        :param config: The workflow configuration.
        """
        self.workflows[name] = workflow_class
        self.configs[name] = config

    def get_workflow_class(self, name: str) -> type:
        """
        Retrieve the workflow class for the given name.

        :param name: The name of the workflow.
        :return: The workflow class.
        """
        return self.workflows[name]

    def get_workflow_config(self, name: str) -> dict:
        """
        Retrieve the workflow configuration for the given name.

        :param name: The name of the workflow.
        :return: The workflow configuration.
        """
        return self.configs[name]

```
llm_workflow_core/manager/workflow_manager.py

from ..types.base_workflow import BaseWorkflow
from ..registry.workflow_registry import WorkflowRegistry


class WorkflowManager:
    def __init__(self, workflow_registry: WorkflowRegistry):
        self.workflow_registry = workflow_registry

    def initialize_workflow(self, name: str):
        workflow_class: BaseWorkflow = self.workflow_registry.get_workflow_class(name)
        return workflow_class()

llm_workflow_core/types/base_workflow.py
"""
base_workflow.py: Provides a BaseWorkflow class to be used as a base class for custom workflows.

The BaseWorkflow class offers a foundation for creating custom workflows with unique IDs, status, and configuration.
"""

from enum import Enum
from utils.unique_id_generator import UniqueIDGenerator
from .config_types import WorkflowStagesConfig


class WorkflowStatus(Enum):
    """
    Enumeration representing the status of a workflow.
    """
    Success = 'Success'
    Started = 'Started'
    Failure = 'Failure'


class BaseWorkflow:
    """
    A base class for custom workflows with unique IDs, status, and configuration.
    """

    name = None
    config = None

    def __init__(self):
        """
        Initialize a BaseWorkflow instance with a unique ID and status.
        """
        self.id = UniqueIDGenerator.generate_id()
        self.status = None

    @classmethod
    def set_workflow_name(cls, name: str):
        cls.name = name

    @classmethod
    def set_workflow_config(cls, config: WorkflowTemplateStagesConfig):
        cls.config = config

    def get_workflow_status(self):
        """
        Get the current status of the workflow.

        Returns:
            WorkflowStatus: The current status of the workflow.
        """
        return self.status

    def start_workflow(self):
        """
        Set the status of the workflow to Started and raise a NotImplementedError for derived classes to implement.
        """
        self.status = WorkflowStatus.Started
        raise NotImplementedError("start_workflow method must be implemented in derived classes")

    def execute_stage(self, stage_config: dict):
        """
        Execute a stage in the workflow and raise a NotImplementedError for derived classes to implement.

        Args:
            stage_config (dict): The configuration of the stage to be executed.
        """
        raise NotImplementedError("execute_stage method must be implemented in derived classes")

"""
config_types.py
This module contains the type definitions for the workflow configuration templates.
"""

from typing import TypedDict, Dict, Type, Union
from .base_stage import BaseStage


class StageTemplateConfig(TypedDict, total=False):
    stage_class: Type[BaseStage]
    stages: Dict[str, 'StageTemplateConfig']


class WorkflowTemplateStagesConfig(TypedDict, total=False):
    stages: Dict[str, StageTemplateConfig]

currently llm_workflow_core is packaged as a separate python package. How user will use this
package is that they will use WorkflowRegistry to get the available installed workflows, which
means they can see all the available workflow configurations.

A workflow can be created by just giving the name of the workflow. When the workflow is being
created, one workflow instance will be created. Internally, the workflow creation will involve
creating all the stages instances as well.

A workflow instance can be started by giving the workflow unique id
A workflow stage can be executed by giving the workflow id, and stage id



Can you combine this requirement with the Task Description from the "refining and enhancing task descriptions" task, and reperform the "refining and enhancing task descriptions" task?


thank you for generating the optimized prompts. Now please execute the task defined by the optimized prompt
