Version 1: This version has steps.

As a top python software developer tasked with modifying and updating a given piece of code in the `>>Code<<` section according to the requirement given in the `>>Requirement<<` section. The content of both sections are situated between `$start$` and `$end$` tokens.

Please follow the steps below. Each step has a title and potentially a description.

1. Articulate your understanding thoroughly of the provided requirements in the `>>Requirement<<` Section:

2. Understand given code in the  `>>Code<<` section:
   - Explain step by step what the code does.
   - And Articulate your reasoning in detail how the provided code aligns or diverges from the provided requirements. 

3. Reasoning About changes to fullfil requirements:
   - Articulate your thoughts on code changes that can fullfil the requirements. Explain why these changes are necessary and how they solve the requirement

4. Present the First Version of the Modified Code:
   - present the first version of the modified code based on step 3.

5. Share Your Knowledge of Clean Code in the identified Language:
   - Discuss SOLID principles and clean code best practices for the identified programming language. 
   - Articulate narratively how these principles and practices can be applied to the code. If no improvements need to be made jump to step 7. If there are improvements ideas, then jump to step 6.

6. Refine the First Version of updated code:
   - Based on the refactoring ideas from step 5, output the improved code. Don't forget correct import if you are introduced new libraries in the updated code. The use following output format 
   - file path: src/.../file 1
     content: 
     [ code of the file]
   - file path: src/.../file 1
     [ code of the file]

7. Mentally test the Modified Code:
   - Articulate your mental step-by-step test of the modified code to ensure it meets the requirements and does not introduce new issues.

>>Requirement<<
...

>>Code<<
...
- Opt for functional programming when the creation of classes is overkill


Version 3: Only criterias and think step by step. Add available commands as well

As a top Python software engineer, you are tasked with the requirements provided between the `$start$` and `$end$` tokens in the `[Requirement]` section.

[Criterias]
- Consider what design patterns can be used.
- Adhere to SOLID principles.
- Adhere to Python coding best practices.
- Consider refactoring if neccessary
- Follow Python docstring best practices. Always include a file-level docstring at the beginning of the file.
- Include complete file path in the output. Make sure code for the file path is in code block.
- Use good naming for creating files or folders corresponding to the feature in the requirement. For reference, here is a sample of the current project file structure:
    src
        ...
        semantic_code
                embedding
                    openai_embedding_creator.py
    tests
        unit_tests
            ...
            semantic_code
                embedding
                    test_openai_embedding_creator.py
        integration_tests
            ...
            semantic_code
                index
                    test_index_service_integration.py
- update relevant docstrings when code changes.
                    
Understand the requirement thorougly, think very carefully step by step, and reason with high details to address the task.

[Requirement]
I have graphql schema.py defined earlier.
```
import json
import strawberry
from strawberry.scalars import JSON
from src.config import config
from src.workspaces.workspace_service import WorkspaceService
from src.workspaces.workspace_setting import WorkspaceSetting
from src.endpoints.graphql.json.custom_json_encoder import CustomJSONEncoder
from src.automated_coding_workflow.automated_coding_workflow import AutomatedCodingWorkflow
from src.automated_coding_workflow.config import WORKFLOW_CONFIG


workflow = AutomatedCodingWorkflow()
workspace_service: WorkspaceService = WorkspaceService()

@strawberry.type
class Query:
    @strawberry.field
    def workflow_config(self) -> JSON:
        custom_encoder = CustomJSONEncoder()
        return custom_encoder.encode(WORKFLOW_CONFIG)

@strawberry.type
class Mutation:
    @strawberry.mutation
    def start_workflow(self) -> bool:
        workflow.start_workflow()
        return True

    @strawberry.mutation
    def add_workspace(self, workspace_path: str) -> bool:
        """
        Adds a new workspace to the workspace service.

        Args:
            workspace_path (str): The root path of the workspace to be added.

        Returns:
            bool: True if the workspace was added successfully, False otherwise.
        """
        try:
            workspace_service.add_workspace(workspace_path)
            return True
        except Exception as e:
            print(f"Error while adding workspace: {e}")
            return False

schema = strawberry.Schema(query=Query, mutation=Mutation)
```

However, i have updated the API for add_workspace to the following
def add_workspace(self, workspace_root_path: str) -> TreeNode

TreeNode is defined as 
```
import json


class TreeNode:
    """
    A class used to represent a file or directory in a directory structure.

    Attributes
    ----------
    name : str
        The name of the file or directory.
    path : str
        The full path of the file or directory.
    is_file : bool
        True if this node represents a file, False if it represents a directory.
    children : list[TreeNode]
        The children of this node. Each child is a TreeNode representing a file or subdirectory.

    Methods
    -------
    add_child(node: TreeNode)
        Adds a child to this node.
    """

    def __init__(self, name: str, path: str, is_file: bool = False):
        self.name = name
        self.path = path
        self.is_file = is_file
        self.children = []

    def to_json(self) -> str:
    """
    Returns a JSON representation of the TreeNode.

    Returns:
        str: The JSON representation of the TreeNode.
    """
    return json.dumps(self.to_dict())

    # rest of code ...
```
Now please update add_workspace in schema.py to return the json representation of the workspace directory tree
$end
