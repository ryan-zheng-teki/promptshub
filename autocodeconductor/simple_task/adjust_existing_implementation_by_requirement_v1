Version 3: Only criterias and think step by step. Add available commands as well

As the best Python software engineer on earth, you are tasked with the requirements provided between the `$start$` and `$end$` tokens in the `[Requirement]` section.

[Criterias]
- Consider what design patterns can be used.
- Adhere to SOLID principles.
- Adhere to Python coding best practices.
- Consider refactoring if better code structure can be achieved
- Follow Python docstring best practices. Always include a file-level docstring at the beginning of the file.
- Include complete file path in the output. Make sure code for the file path is in code block.
- Use good naming for creating files or folders corresponding to the feature in the requirement. For reference, here is a sample of the current project file structure:
    src
        ...
        semantic_code
                embedding
                    openai_embedding_creator.py
    tests
        unit_tests
            ...
            semantic_code
                embedding
                    test_openai_embedding_creator.py
        integration_tests
            ...
            semantic_code
                index
                    test_index_service_integration.py
- Always use absolute import instead of relative import
- Update relevant docstrings for code changes.
                    
Think very carefully step by step, and reason comprehensively to address to task.

[Requirement]

```
Think about a way to show the frontend the prompt, and the variable part. So frontend
can fill the variable and submit the input, so backend can construct the file prompt





As a top Python software engineer, you are tasked with the requirements provided between the `$start$` and `$end$` tokens in the `[Requirement]` section.

[Criterias]
- Consider what design patterns can be used.
- Adhere to SOLID principles.
- Adhere to Python coding best practices.
- Consider refactoring if neccessary
- Follow Python docstring best practices. Always include a file-level docstring at the beginning of the file.
- Include file paths with their complete codes in code block in the output for easy copy paste.
- Consider whether to create a new folder or use an existing one for file placement. Use appropriate and descriptive naming when creating files and folders to correspond with the required features. 
  For reference, here is a sample of the current project file structure:
    src
        ...
        semantic_code
                embedding
                    openai_embedding_creator.py
    tests
        unit_tests
            ...
            semantic_code
                embedding
                    test_openai_embedding_creator.py
        integration_tests
            ...
            semantic_code
                index
                    test_index_service_integration.py
- Always use absolute import instead of relative import
- Update relevant docstrings when code changes.
                    
Think very carefully step by step  to address the task.

[Requirement]
Normally when we start a new project, we have to scalfolding a project with minimal setup. For example, for frontend Vue3, we normally use vite+graphql. For python project, with fastapi, the basic folder structure are mostly the same.
The project root folder is provided by WorkspaceSetting object
```

```



As the best Python software engineer on earth, address the requriements outlined between the `$start$` and `$end$` tokens in the `[Requirement]` section.

[Guidelines]
- Use appropriate design patterns where neccessary.
- Follow SOLID principles and Python's best coding practices.
- Consider refactoring where necessary.
- Follow python docstring best practices, ensuring each file begins with a file-level docstring.
- Include file paths with their complete codes in code block in the output, so i can easily copy and paste. Do not use placeholders.
- Explain whether to create a new folder or use an existing one for file placement. Use descriptive naming conventions for files and folders that correlate with the requirement's features. For context, the current project's file structure looks like this:

    - src
        - ...
        - semantic_code
            - embedding
                - openai_embedding_creator.py
    - tests
        - unit_tests
            - ...
            - semantic_code
                - embedding
                    - test_openai_embedding_creator.py
        - integration_tests
            - ...
            - semantic_code
                - index
                    - test_index_service_integration.py
                    
- Always use absolute imports over relative ones.
- Update docstrings in line with any code modifications.

Think step by step, and reason comphrehensively to address the task.
[Requirement]
$start$
I have search_result.py defined
```
from typing import List

from src.source_code_tree.code_entities.base_entity import CodeEntity

class ScoredEntity:
    """
    Represents a code entity with an associated score.

    Args:
        entity (CodeEntity): The code entity.
        score (float): The score of the entity.
    """
    def __init__(self, entity: CodeEntity, score: float):
        self.entity = entity
        self.score = score

class SearchResult:
    """
    Represents a search result, containing the total count of results, 
    and a list of ScoredEntity objects.

    Args:
        total (int): The total count of results.
        entities (List[ScoredEntity]): A list of scored entities.
    """

    def __init__(self, total: int, entities: List[ScoredEntity]):
        self.total = total
        self.entities = entities
```

I also have graphql api already defined. 
```
    @strawberry.field
    def search_code_entities(self, query: str) -> JSON:
        """
        Searches for relevant code entities based on the provided query.

        Args:
            query (str): The search query.

        Returns:
            JSON: The search results.
        """
        try:
            search_result: SearchResult = search_service.search(query)
            return search_result.to_json()
        except Exception as e:
            error_message = f"Error while searching code entities: {str(e)}"
            logger.error(error_message)
            return json.dumps({"error": error_message})
```
THe CodeEntity has already one interface 
```
Class CodeEntity
    @abstractmethod
    def to_json(self) -> str:
        """
        Convert the code entity to json representation
        
        Note: This method should be implemented by the subclasses to
              provide specific conversion logic.
        
        :return: A json representation of the code entity.
        :rtype: str
        """
```
the to_json from SearchResult needs to be implemented.
$stop$
