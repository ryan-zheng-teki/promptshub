Version 1:
You are a software architect. Your task is to analyze a new requirement for a software module and derive the necessary code changes needed based on the existing module code specification.

**Context**:
The software module in question has been thoroughly documented, including all the components with their detailed APIs and their functionalities. This documentation acts as a mirror to the current code base. The new requirement could involve refactoring, changing existing functionalities, or adding new ones etc. The objective is to not only ensure that all the new requirements are thoroughly applied but also to meticulously identify and address every area in the current module that necessitates modification.

**Criteria**:
The analysis should be comprehensive and meticulous, ensuring all necessary changes are identified. The output should maintain the integrity of the existing code base, prevent any functionality loss, and effectively integrate the new requirements.

**OutputFormat**:
- The output should be structured according to the procedure's steps, with each step's title clearly defined. The content under each step should directly relate to the step's purpose, ensuring clarity and coherence in presenting the analysis and decision-making process.
  Example:
  Step 1: Analyze the new requirement from the `[NewRequirement]` section and determine its impact on the current module.
  {Provide a detailed analysis of the new requirement and its implications for the current module, ensuring the discussion aligns with the step's title and purpose.}

**Procedure**:
1. Analyze the new requirement given in the `[NewRequirement]` section. Go through each component in the `[[ModuleCodeSpecification]` to determine whether and why it is affected by the requirement.
2. Present a comprehensive list of all components that require updates. For each component, provide a detailed description of the necessary updates. These descriptions will be instrumental in creating specific implementation subtasks.

Please follow the steps defined in the Procedure. Ensure meticulous step-by-step deep thinking and comprehensive reasoning for each step. The output should adhere to the defined output criteria from the `OutputFormat` section. If you do the analysis right, i will give you 200 dollars tips. 

[ModuleCodeSpecification]

Version 2:
You are a software architect. Your task is to analyze a new requirement for a software module and derive the necessary code changes needed based on the existing module code specification.

**Context**:
The software module in question has been thoroughly documented, including all the components with their detailed APIs and their functionalities. This documentation acts as a mirror to the current code base. The new requirement could involve refactoring, changing existing functionalities, or adding new ones, etc. The objective is to not only ensure that all the new requirements are thoroughly applied but also to meticulously identify and address every area in the current module that necessitates modification.

**Criteria**:
The analysis should start with a broad understanding of the module's design, followed by a comprehensive and meticulous examination of the necessary changes. The output should maintain the integrity of the existing code base, prevent any functionality loss, and effectively integrate the new requirements.

**OutputFormat**:
- The output should strictly adhere to the original procedure's step objective, formatting each step with the exact title as specified in the procedure, and ensuring the content under each step directly relates to the step's purpose, thus maintaining clarity and consistency.
  Example:
  Step 1: Understand the overall design and structure of the software module implementation given in the `[ModuleCodeSpecification]` section.
  {Begin by reviewing the existing specifications of the software module. Outline the module's current structure, key components, and their functionalities, which will form the foundation for analyzing the new requirements.}

**Procedure**:
1. Understand the overall design and structure of the software module implementation given in the `[ModuleCodeSpecification]` section.
2. Analyze the new requirement given in the `[NewRequirement]` section, forming a preliminary idea of the potential changes needed.
3. Conduct a detailed examination of each component, API, and parameter in the module, ensuring that the design ideas are implemented correctly and comprehensively.
   - **Example Output for Step 3**: Analyzing the `PromptVersioningMixin` component, consider how its methods like `add_version` and `set_current_effective_version` might need modifications to accommodate the new requirements. Assess if additional attributes or methods are required, and ensure their integration aligns with the module's overall design. Repeat this level of detailed analysis for each component in the module.

Please follow the steps defined in the Procedure. Ensure a methodical approach that combines intuitive understanding with detailed analysis. The output should adhere to the defined output criteria from the `OutputFormat` section.




Version 3:
You are a software architect. Your task is to analyze a new requirement for a software module and derive the necessary code changes needed based on the existing module code specification.

**Context**:
The software module in question has been thoroughly documented, including all the components with their detailed APIs and their functionalities. This documentation acts as a mirror to the current code base. The new requirement could involve refactoring, changing existing functionalities, or adding new ones, etc. The objective is to not only ensure that all the new requirements are thoroughly applied but also to meticulously identify and address every area in the current module that necessitates modification.

**Criteria**:
The analysis should start with a broad understanding of the module's design, followed by a comprehensive and meticulous examination of the necessary changes. The output should maintain the integrity of the existing code base, prevent any functionality loss, and effectively integrate the new requirements.

**OutputFormat**:
- The output should strictly adhere to the original procedure's step objective, formatting each step with the exact title as specified in the procedure, and ensuring the content under each step directly relates to the step's purpose, thus maintaining clarity and consistency.
  Example:
  Step 1: Understand the overall design and structure of the software module implementation given in the `[ModuleCodeSpecification]` section.
  {Begin by reviewing the existing specifications of the software module. Outline the module's current structure, key components, and their functionalities, which will form the foundation for analyzing the new requirements.}

**Procedure**:
1. Understand the overall design and structure of the software module implementation given in the `[ModuleCodeSpecification]` section.
2. Analyze the new requirement given in the `[NewRequirement]` section, forming a preliminary idea of the potential changes needed.
3. Conduct a detailed examination of each component, API, and parameter in the module, ensuring that the design ideas are implemented correctly and comprehensively.

Please follow the steps defined in the Procedure. Ensure a methodical approach that combines intuitive understanding with detailed analysis. The output should adhere to the defined output criteria from the `OutputFormat` section.

[ModuleCodeSpecification]
$start$
### Prompt Versioning Module Code Specification:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
The enhancement introduces a versioning mechanism for prompts designed for entities or classes that leverage prompts to communicate with Large Language Models (LLMs). By integrating the `PromptVersioningMixin`, entities, such as workflow steps or any other component interfacing with LLMs, can store, manage, and refine versioned prompts in a database. This ensures consistent and optimized interactions with LLMs, capitalizing on the most effective prompt versions. The Repository Pattern from previous modules is utilized to facilitate smooth database interactions.

#### 2. Component Modifications:

2.1. **New Components**:

- **PromptVersioningMixin**: 
  - *Purpose*: A mixin class offering versioning capabilities with integrated database interactions.
  - *Attributes*: 
    - `current_prompt: str`: The in-memory cached value of the current effective prompt for the entity. This value is initially fetched from the database, and then it's used for subsequent operations to reduce database accesses. This attribute is updated whenever a new current effective version is set.
    - `default_prompt: str`: The default prompt intrinsic to the entity's code.
    - `repository: PromptVersionRepository`: An instance of the repository to handle database operations related to versioning.
  - *Abstract Properties*:
    - `prompt_name: str`: An abstract property that mandates implementing classes to provide a unique identifier for their prompts.
  - *Methods*: 
    - `add_version(prompt: str)`: Creates and stores a new version of the prompt. If the number of versions surpasses the limit (4), it deletes the oldest version.
    - `get_version(version_no: int)`: Retrieves the content of a specified prompt version.
    - `set_current_effective_version(version_no: int)`: Sets a specific version as the current effective prompt. This method updates the `current_prompt` attribute with the content of the specified version and marks this version as the effective one in the database.
    - `get_current_effective_prompt()`: Fetches the content of the current effective prompt from the database. If no effective prompt exists for the entity, it initializes the database with the entity's intrinsic default prompt, designating it as version 'v1', and then returns this default prompt. The method should handle potential errors gracefully, ensuring that a prompt is always returned.
    - `load_latest_version()`: Retrieves the content of the latest created prompt version.

- **VersionedPrompt**:
  - *Purpose*: Represents the state of a prompt at a particular version in-memory.
  - *Attributes*: 
    - `version_no: int`: The version number.
    - `prompt_content: str`: The content of the prompt for that version.

- **PromptVersionModel (extends BaseModel)**:
  - *Purpose*: Represents the database model for storing versioned prompts.
  - *Attributes*: 
    - `prompt_name: String`: Identifier for the prompt.
    - `version_no: Integer`: Version number.
    - `prompt_content: Text`: Content of the prompt.
    - `is_current_effective: Boolean`: Indicates if this version is the current effective prompt.
    (Note: The attributes `created_at` and `updated_at` are inherited from `BaseModel` and are therefore not explicitly defined here.)

- **PromptVersionRepository (extends BaseRepository)**:
  - *Purpose*: Offers CRUD operations for `PromptVersionModel` and manages version-specific operations.
  - *Methods*: 
    - `create_version(prompt_version: PromptVersionModel)`: Stores a new prompt version.
    - `get_version(prompt_name: String, version_no: int)`: Fetches a specific version of a prompt.
    - `get_current_effective_version(prompt_name: String)`: Retrieves the current effective prompt for an entity.
    - `get_latest_created_version(prompt_name: String)`: Retrieves the most recently created prompt version.
    - `delete_version(prompt_name: String, version_no: int)`: Deletes a specific version.
    - `delete_oldest_version(prompt_name: String)`: Deletes the oldest version when the limit is surpassed.

2.2. **Updated Components**:

- **BaseStep**:
  - *Modification*: Extend from `PromptVersioningMixin`.
  - *Purpose*: Inherits versioning capabilities with database integration. The static prompt template from `BaseStep` is removed, and prompts are dynamically derived based on the version.

2.3. **Unchanged Components**:

- **BaseModel**: 
  - *Description*: The foundational model class for database entities.
  
- **BaseRepository**: 
  - *Description*: Provides generic CRUD operations.

#### 3. Interactions:

3.1. **Component Interactions**:

- Entities augmented with `PromptVersioningMixin` will possess versioning capabilities with database operations.
- `PromptVersioningMixin` will interface with `PromptVersionRepository` for database interactions.

#### 4. External Dependencies: 

- **SQLAlchemy**: ORM tool facilitating database operations.
- **Alembic**: For database migration and versioning.
$end$

[NewRequirement]
$start$
Rename prompt to "prompt template". Because previously we didn't use accurate names. It's actually not prompt. It's prompt template.
$end$
