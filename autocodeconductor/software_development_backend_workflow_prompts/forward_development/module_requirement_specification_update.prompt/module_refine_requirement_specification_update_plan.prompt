


Version 2: Improved the steps "Preliminarily Identify The Most Relevant Items" to be more specific.

You are a senior software architect, tasked with creating a "Plan Of Change" for an existing "Module Specification" in the `[ModuleA]` section. Your goal is to adapt ModuleA based on the major responsibilities of a newly developed "Module Specification" in the `[ModuleB]` section. This plan will detail modifications or enhancements ensuring that ModuleA effectively utilizes the capabilities of ModuleB.

**Background**:
In software engineering, as modules evolve, it's vital to regularly reassess and align them with newer functionalities. A "Plan Of Change" provides a systematic approach for this, ensuring that systems remain modular, coherent, and updated.

**Procedure**:
1. Understand the primary purpose of ModuleB from the "Module Description" section of `[ModuleB]`.

2. **Identify Functionally Relevant Items Based Primary Purpose Of ModuleB**: Browse through each category under both `5.1. Functional Specifications` and `5.2. Technical Specifications` in the `5. Specifications` section of ModuleA. For each category:
   - Identify specification items that are functionally related to the "How To Use This Module" section of ModuleB. This relevance can be determined by the presence of words, phrases, or concepts similar to those found in that section.
   - Summarize these specification items as they hold the most relevance with the "How To Use This Module" content from ModuleB.
   - This step will form a detailed shortlist for deeper analysis.

3. For each specification item shortlisted in step 2, follow the structured reasoning:

   a. **Define the Current Functionality**:
      "When examining the specification item from ModuleA, it is observed that it encompasses [specific functionality or role of the specification item]."
      
   b. **Introduce and Contrast with "How To Use This Module" from ModuleB**:
      "On the other hand, the 'How To Use This Module' section from ModuleB introduces [specific capability or instruction], which has the potential to [complement/overlap with/challenge] the aforementioned functionality of the specification item."
      
   c. **Provide Clear Reasoning for Changes and Outcomes**:
      - "Given this relationship between the functionalities, it becomes [logical conclusion: evident/apparent/clear] that there's a need to [specific action: enhance/update/retain/remove/add] this specification item in ModuleA."
      - If modifying: "The modified description for this specification item, considering the instructions from 'How To Use This Module' in ModuleB, would be [new detailed functional specification description]."
      - If removing: "This specification item from ModuleA is marked for removal due to [specific reason relating to ModuleB's usage instructions]."
      - If identifying a new requirement: "A new specification item for ModuleA, influenced by the 'How To Use This Module' content from ModuleB, would be [detailed description of the new specification item]."

4. Based on the structured reasoning from steps 3 and 4, start to draft the documentation following the structure of the `[Example]`.

Please follow the steps defined in the Procedure. Take a deep breath, think step by step meticulously, and provide comprehensive reasoning for each step.


[Example]



You are a senior software architect analyzing two software module specifications provided in `[ModelA]` and `[ModuleB]` sections separately. Your objective is to understand the functionalities of ModuleB and identify relevant items from ModuleA that might be impacted or enhanced by ModuleB.

**Criteria**:
The output should be a list of relevant items from ModuleA that have the potential to interact with ModuleB, along with the reasoning behind each choice.

**Procedure**:
1. Understand the "How To Use This Module" section from `[ModuleB]`.
2. **Reason To Find Out The Relevant Specification Items From ModuleA Based on "How To Use This Module" from ModuleB:**
   - Browse through each category under both `5.1. Functional Specifications` and `5.2. Technical Specifications` in the `5. Specifications` section of ModuleA. For each specification item:
     1. Articulate the functionality in the scope of ModuleA.
     2. **Compare** it with the "How To Use This Module" content from ModuleB.
     3. Reason Thoroughly Step By Step to find out whether the item has any semantically related words, phrases, or concepts similar to those in ModuleB.
     4. Based on the reasoning, judge its relevance based on your reasoning.
     5. If deemed relevant, **Document** the specification item and provide a brief justification for its inclusion in relation to the content from ModuleB.

Please follow the steps defined in the Procedure. Ensure meticulous step-by-step thinking and comprehensive reasoning for each step.


[ModuleA]


[ModuleB]



Version 3: Prompting language version.

**Introduction to the Prompting Procedure Programming**:

The Prompting Procedure Programming, arising from the blend of conventional programming and natural language, aims to provide a more structured approach to interacting with large language models like ChatGPT. Its foundational principle is to merge the logical precision of traditional programming languages with the comprehensibility of natural language. This synergy ensures clearer instructions to the model, boosting the efficiency and accuracy of its outputs.

**Why the Need for the Prompting Procedure Programming?**:
Large language models excel in understanding and producing natural language. However, there are scenarios where unstructured prompts may yield ambiguous or inaccurate outcomes. By integrating structured constructs such as loops, conditions, and directives, the Prompting Procedure Programming offers clearer and more specific instructions, substantially minimizing the possibility of errors.

**Language Elements and Their Descriptions**:

1. **GLOBAL DIRECTIVE**:
- **Definition**: A high-level command setting the overall tone or giving overarching instructions for the entire procedure.
- **Usage**: Ensures the entire procedure adheres to a consistent set of rules or guidelines.

1. **DIRECTIVE**:
- **Definition**: Specific rules or guidelines designed for a particular action.
- **Usage**: Offers a detailed level of instruction for actions, ensuring compliance with particular conditions or demands.

1. **Global Variables**:
- **Definition**: Variables available throughout the entire procedure.
- **Usage**: Initialized at the procedure's onset and usable in any following step or action.

1. **Step**:
- **Definition**: Denotes a distinct phase or objective within the procedure, similar to how humans break down a large task into manageable segments or steps.
- **Usage**: Marks a specific section or phase in the execution plan. Each step can contain multiple actions, which are essentially the implementation details of that step.

1. **Action**:
- **Definition**: A component of its parent step, indicating a distinct action to be taken.
- **Usage**: Specifies the exact action to be executed, ensuring that each action within a step is clearly delineated.
- **Example**:
```
content, objectives = Action: DISSECT the promptContent TO grasp ITS content AND objectives
```

1. **IF and ELSE**:
- **Definition**: Conditional constructs to present a condition (IF) and offer an alternative action (ELSE).
- **Usage**: Allows conditional execution of steps or actions based on set criteria.

1. **LABEL**:
- **Definition**: Highlights a specific line or point in the procedure.
- **Usage**: Serves as a reference for JUMP directives.

1. **JUMP**:
- **Definition**: Commands the execution to move to a designated labeled line.
- **Usage**: Works with LABEL to direct the execution flow.
- **Example**:
```
LABEL StartOfIteration:
... [some actions]
JUMP to "StartOfIteration"
```

1. **EXECUTION PLAN**:
- **Definition**: An organized sequence of steps or actions detailing the order and flow of execution within a designated block.
- **Usage**: Reflects the thought process humans undergo when planning tasks before execution.

1.  **RETURN**:
- **Definition**: A command to relay the result from a particular step.
- **Usage**: Enables the returned value to be passed as an argument to subsequent steps or actions. 
- **Example**:
```
Step AnalyzeThePrompt(promptContent):
    content, objectives = Action: DISSECT the promptContent TO grasp ITS content AND objectives
    RETURN content, objectives
```

**Current State of the Language**:
At present, the Prompting Procedure Programming includes only the aforementioned elements. No additional constructs or components have been added. This ensures user-friendliness and straightforwardness but also leaves room for potential expansions based on evolving requirements and user feedback.


[PromptingProcedure]
BEGIN PROCEDURE:

Role & Objective:
You are a senior software architect. Your mission is to analyze two software module specifications provided in `[ModuleA]` and `[ModuleB]` sections. Understand the functionalities of ModuleB and then identify and list items from ModuleA that are functionally related to ModuleB.

Context:
In the evolving landscape of software architecture, introducing new modules often necessitates revisiting and updating existing ones. This practice ensures optimal modularity and the extraction of common functionalities. ModuleB, being a newly developed model, may bring with it changes or enhancements that affect ModuleA. It's crucial to discern how ModuleB interacts or might interact with ModuleA, ensuring ModuleA requirements stay up-to-date.

Step UnderstandModuleBUsage():
    Action: READ "How To Use This Module" FROM `[ModuleB]`, EXTRACT key functional and technical aspects
    RETURN keyAspectsModuleB

Step AnalyzeAndDecideRelevance(specificationItem, keyAspectsModuleB):
    Action: Undertand specificationItem
    Action: COMPARE specificationItem WITH keyAspectsModuleB
    Action: REASON out any semantically related words, phrases, or concepts
    Acion:  DECIDE relevance BASED ON reasoning
    IF item IS relevant:
        DOCUMENT item AND PROVIDE brief justification
    RETURN relevantItemWithReasoning

Step IdentifyRelevantItemsFromModuleA(keyAspectsModuleB):
    FOR EACH category IN `5.1. Functional Specifications` AND `5.2. Technical Specifications` OF `[ModuleA]`:
        FOR EACH specificationItem under the category
            relevantItemWithReasoning = AnalyzeAndDecideRelevance(category, specificationItem, keyAspectsModuleB)
    RETURN aggregatedRelevantItemsWithReasoning

Step AwaitUserToProvideModuleA():
   moduleA_RequirementSpecification = Action: Ask user to provide ModuleA requirement specification
   return moduleA_RequirementSpecification

Step AwaitUserToProvideModuleB():
   moduleB_RequirementSpecification = Action: Ask user to provide ModuleB requirement specification
   return moduleB_RequirementSpecification

EXECUTE:
    moduleA_RequirementSpecification = AwaitUserToProvideModuleA()
    moduleB_RequirementSpecification = AwaitUserToProvideModuleB()
    aggregatedRelevantItemsWithReasoning = IdentifyModuleARelevantItemsAgainstModuleB(keyAspectsModuleB)
END PROCEDURE


[ModuleA]
### Automated Coding Workflow Module Specification

#### 1. Module Description:
This module facilitates the definition, management, and execution of a multi-step automated coding workflow. It encompasses functionalities to initialize workflow steps from configurations, convert workflow instances to JSON representations, and execute specific steps or the entire workflow.

#### 2. Module Dependencies:
- **LLM Integration Module**: The Automated Coding Workflow Module uses functionalities from the LLM Integration Module to communicate with large language models like ChatGPT and manage external dependencies.

#### 3. How To Use This Module:
(Empty as the main purpose of this section is to describe how other modules can use the Automated Coding Workflow Module.)

#### 4. Specifications:

4.1. **Functional Specifications**:

- **Workflow Management**:
   - Define and manage a multi-step automated coding workflow.
   - Each step in the workflow can potentially have sub-steps.
   - Integrate with the LLM Integration Module to manage external dependencies.
   - Initialize steps of the workflow from a given configuration.
   - Convert the workflow instance to a JSON representation.
   - Start the entire workflow process.
   - Execute specific steps within the workflow using their ID.

- **Step Definition**:
   - Each step is represented by an instance of a class derived from `BaseStep`.
   - Construct a unique ID for each step instance.
   - Construct a dynamic prompt for each step.
   - Process the response from the LLM Integration Module for each step.
   - Define the execution logic for each step.

- **Requirement Gathering**:
   - Represent a step where coding requirements are presented to the user.
   - Prompt the user with a coding requirement and provide guidelines on how to address it.
   - Construct a prompt for this step using a template.
   - Process the response from the LLM Integration Module for this step.

- **Architecture Design Step**:
   - Represent the design stage in the coding workflow.
   - Use a template for constructing the design stage's prompt.

4.2. **Technical Specifications**:
(No technical specifications were provided in the initial document. This section can be populated when such specifications are defined.)


[ModuleB]
### Prompt Versioning Mechanism Module Specification

#### 1. Module Description:
This module manages versioned prompts for Large Language Models (LLMs). It provides foundational functionality for entities to handle prompt variations, enabling comparative analysis between different versions. Central to this module is an Abstract Entity designed to be extended by other entities desiring prompt versioning capabilities. While the module focuses on prompt management, it does not oversee direct communication with LLMs.

#### 2. Module Dependencies:
- **None**: This module operates independently and does not rely on other modules within the application.

#### 3. How To Use This Module:
- Entities wishing to utilize prompt versioning must extend the provided Abstract Entity.
- The Abstract Entity defines a default prompt that must be overridden by extending entities to suit their specific needs.
- Once an entity extends the Abstract Entity, the module automatically manages the creation, management, and retrieval of versioned prompts for that entity.

#### 4. Specifications:

4.1. **Functional Specifications**:

- **Single Effective Prompt per Entity**:
   - At any point, only one effective prompt is allowed for an entity.
   - Users (such as other backend systems or APIs) can designate any archived version as the current effective prompt, superseding the prior effective prompt.

- **Entity-Specific Default Prompt**:
   - Every entity or component that communicates with LLMs and extends the Abstract Entity must override its default prompt.
   - If prompts specific to an entity are absent in the database, the overridden default prompt initializes the database as v1 and acts as the immediate effective prompt.

- **Dynamic Initialization of Versioned Prompts**:
   - Before any LLM communication, the system retrieves the effective prompt for the respective entity from the database.
   - If a version for an entity is not in the database, the system uses the entity's overridden default prompt for initialization.

- **Prompt Version Management**:
   - Entities can introduce a new prompt version upon modifying the existing prompt.
   - A maximum of 4 prompt versions are maintained for each entity.
   - If a new version exceeds the 4-version cap, the oldest version is purged.

- **Comparative Analysis**:
   - The system supports API-based comparative evaluations of different prompt versions, with future plans to incorporate a side-by-side comparison tool.

- **Database Management**:
   - Versions are depicted using simple incremented numerals (e.g., v1, v2, etc.).
   - Each version's creation/modification timestamp is documented.

4.2. **Technical Specifications**:

- **Database Interaction**:
   - Efficient CRUD (Create, Read, Update, Delete) operations for prompt version management are paramount.
   - Versions are recorded with unique identifiers, timestamps, and version numbers.

