


Version 2: Improved the steps "Preliminarily Identify The Most Relevant Items" to be more specific.

You are a senior software architect, tasked with creating a "Plan Of Change" for an existing "Module Specification" in the `[ModuleA]` section. Your goal is to adapt ModuleA based on the major responsibilities of a newly developed "Module Specification" in the `[ModuleB]` section. This plan will detail modifications or enhancements ensuring that ModuleA effectively utilizes the capabilities of ModuleB.

**Background**:
In software engineering, as modules evolve, it's vital to regularly reassess and align them with newer functionalities. A "Plan Of Change" provides a systematic approach for this, ensuring that systems remain modular, coherent, and updated.

**Procedure**:
1. Understand the primary purpose of ModuleB from the "Module Description" section of `[ModuleB]`.

2. **Identify Functionally Relevant Items Based Primary Purpose Of ModuleB**: Browse through each category under both `5.1. Functional Specifications` and `5.2. Technical Specifications` in the `5. Specifications` section of ModuleA. For each category:
   - Identify specification items that are functionally related to the "How To Use This Module" section of ModuleB. This relevance can be determined by the presence of words, phrases, or concepts similar to those found in that section.
   - Summarize these specification items as they hold the most relevance with the "How To Use This Module" content from ModuleB.
   - This step will form a detailed shortlist for deeper analysis.

3. For each specification item shortlisted in step 2, follow the structured reasoning:

2. **Reason To Find Out The Relevant Specification Items From ModuleA Based on "Module Description" from ModuleB:**
   - Browse through each category under both `4.1. Functional Specifications` and `4.2. Technical Specifications` in the `4. Specifications` section of ModuleA. For each specification item, follow the structured reasoning:
   a. **Define the Current Functionality**:
      "When examining the specification item from ModuleA, it is observed that it encompasses [specific functionality or role of the specification item]."
      
   b. **Introduce and Contrast with "How To Use This Module" from ModuleB**:
      "On the other hand, the 'How To Use This Module' section from ModuleB introduces [specific capability or instruction], which has the potential to [complement/overlap with/challenge] the aforementioned functionality of the specification item."
      
   c. **Provide Clear Reasoning for Changes and Outcomes**:
      - "Given this relationship between the functionalities, it becomes [logical conclusion: evident/apparent/clear] that there's a need to [specific action: enhance/update/retain/remove/add] this specification item in ModuleA."
      - If modifying: "The modified description for this specification item, considering the instructions from 'How To Use This Module' in ModuleB, would be [new detailed functional specification description]."
      - If removing: "This specification item from ModuleA is marked for removal due to [specific reason relating to ModuleB's usage instructions]."
      - If identifying a new requirement: "A new specification item for ModuleA, influenced by the 'How To Use This Module' content from ModuleB, would be [detailed description of the new specification item]."

4. Based on the structured reasoning from steps 3 and 4, start to draft the documentation following the structure of the `[Example]`.

Please follow the steps defined in the Procedure. Take a deep breath, think step by step meticulously, and provide comprehensive reasoning for each step.


[Example]


**Procedure**:
1. Understand the "Module Description" section from `[ModuleB]`.
2. Reason To Find Out The Relevant Specification Items From ModuleA Based on "Module Description" of ModuleB:
   - Browse through each category under both `4.1. Functional Specifications` and `4.2. Technical Specifications` in the `4. Specifications` section of ModuleA. For each specification item of the current category, perform the structured reasoning steps:
   a. **Define the Current Functionality**:
      "When examining the specification item from ModuleA, it is observed that it encompasses [specific functionality or role of the specification item]."
      
   b. **Introduce and Contrast with "Module Description" from ModuleB**:
      "On the other hand, the 'Module Description' section from ModuleB introduces [specific capability or instruction], which has the potential to [complement/overlap with/challenge] the aforementioned functionality of the specification item."
      
   c. **Provide Clear Reasoning To check Relevance**:
      - "Given this relationship between the functionalities, it becomes evident ...

3. Present the relevant specification items under their specification category.

Please follow the steps defined in the Procedure. Ensure meticulous step-by-step thinking and comprehensive reasoning for each step. 

[ModuleA]
### Automated Coding Workflow Module Requirements Specification

#### 1. Module Description:
This module facilitates the definition, management, and execution of a multi-step automated coding workflow. It encompasses functionalities to initialize workflow steps from configurations, convert workflow instances to JSON representations, and execute specific steps or the entire workflow.

#### 2. Module Dependencies:
- **LLM Integration Module**: This module utilizes the "LLM Integration Module" to interface with large language models like ChatGPT and execute coding instructions.

#### 3. Symbols & Usage:
- **[⇌ LLM Integration Module]**: Denotes functionalities or interactions that are directly tied to the LLM Integration Module.

#### 4. Specifications:

4.1. **Functional Specifications**:

- **Workflow Management**:
   - Define and manage a multi-step automated coding workflow.
   - Each step in the workflow can potentially have sub-steps.
   - [⇌ LLM Integration Module] Integrate with the "LLM Integration Module" to manage LLM communications.
   - Initialize steps of the workflow from a given configuration.
   - Convert the workflow instance to a JSON representation.
   - Start the entire workflow process.
   - Execute specific steps within the workflow using their ID.

- **Shared Step Functionalities**:
   - Construct a unique ID for each step instance.
   - [⇌ LLM Integration Module] Process the response from the "LLM Integration Module" for each step.
   - Define the execution logic for each step.
   - Construct a dynamic prompt for each step.

- **Requirement Clarification Step**:
   - Represent a step where coding requirements are presented to the user.
   - Define a default prompt template for this step.

- **Architecture Design Step**:
   - Represent the design stage in the coding workflow.
   - Define a default prompt template for this step.

4.2. **Technical Specifications**:
(No technical specifications were provided in the initial document. This section can be populated when such specifications are defined.)



Version 3: Prompting language version.

**Introduction to the Prompting Procedure Programming**:

The Prompting Procedure Programming, arising from the blend of conventional programming and natural language, aims to provide a more structured approach to interacting with large language models like ChatGPT. Its foundational principle is to merge the logical precision of traditional programming languages with the comprehensibility of natural language. This synergy ensures clearer instructions to the model, boosting the efficiency and accuracy of its outputs.

**Why the Need for the Prompting Procedure Programming?**:
Large language models excel in understanding and producing natural language. However, there are scenarios where unstructured prompts may yield ambiguous or inaccurate outcomes. By integrating structured constructs such as loops, conditions, and directives, the Prompting Procedure Programming offers clearer and more specific instructions, substantially minimizing the possibility of errors.

**Language Elements and Their Descriptions**:

1. **GLOBAL DIRECTIVE**:
- **Definition**: A high-level command setting the overall tone or giving overarching instructions for the entire procedure.
- **Usage**: Ensures the entire procedure adheres to a consistent set of rules or guidelines.

2. **DIRECTIVE**:
- **Definition**: Specific rules or guidelines designed for a particular action.
- **Usage**: Offers a detailed level of instruction for actions, ensuring compliance with particular conditions or demands.

3. **Global Variables**:
- **Definition**: Variables available throughout the entire procedure.
- **Usage**: Initialized at the procedure's onset and usable in any following step or action.

4. **Step**:
- **Definition**: Denotes a distinct phase or objective within the procedure, similar to how humans break down a large task into manageable segments or steps.
- **Usage**: Marks a specific section or phase in the execution plan. Each step can contain multiple actions, which are essentially the implementation details of that step.

5. **Action**:
- **Definition**: A component of its parent step, indicating a distinct action to be taken.
- **Usage**: Specifies the exact action to be executed, ensuring that each action within a step is clearly delineated.
- **Example**:
```
content, objectives = Action: DISSECT the promptContent TO grasp ITS content AND objectives
```

6. **IF and ELSE**:
- **Definition**: Conditional constructs to present a condition (IF) and offer an alternative action (ELSE).
- **Usage**: Allows conditional execution of steps or actions based on set criteria.

7. **LABEL**:
- **Definition**: Highlights a specific line or point in the procedure.
- **Usage**: Serves as a reference for JUMP directives.

8. **JUMP**:
- **Definition**: Commands the execution to move to a designated labeled line.
- **Usage**: Works with LABEL to direct the execution flow.
- **Example**:
```
LABEL StartOfIteration:
... [some actions]
JUMP to "StartOfIteration"
```

9. **EXECUTION PLAN**:
- **Definition**: An organized sequence of steps or actions detailing the order and flow of execution within a designated block.
- **Usage**: Reflects the thought process humans undergo when planning tasks before execution.

10.  **RETURN**:
- **Definition**: A command to relay the result from a particular step.
- **Usage**: Enables the returned value to be passed as an argument to subsequent steps or actions. 
- **Example**:
```
Step AnalyzeThePrompt(promptContent):
    content, objectives = Action: DISSECT the promptContent TO grasp ITS content AND objectives
    RETURN content, objectives
```

**Current State of the Language**:
At present, the Prompting Procedure Programming includes only the aforementioned elements. No additional constructs or components have been added. This ensures user-friendliness and straightforwardness but also leaves room for potential expansions based on evolving requirements and user feedback.

With the understanding of "Prompting Programming Language", now please perform as human brain who is going to execute the `EXECUTION PLAN` in the prompting procedure given in the `[PromptingProcedure]`. Please try really really hard like a human to squeez your brain to produce accurate results. Otherwise, my mom will kill me. 

[PromptingProcedure]
BEGIN PROCEDURE:

Role & Objective:
You are a senior software architect. Your mission is to analyze two software module specifications provided in `[ModuleA]` and `[ModuleB]` sections. Understand the functionalities of ModuleB and then identify and list items from ModuleA that might be impacted or enhanced by ModuleB.

GLOBAL DIRECTIVE: Ensure meticulous analysis for each `Action` of the `Step` defined in the prompting code.
GLOBAL DIRECTIVE: Before executing a `Step`, print: "Initiating Step: [step_name] within the global `EXECUTION PLAN`". 
GLOBAL DIRECTIVE: The implementation in a `Step` will be executed in sequence. Additionally, before each `Action`, print: "Executing Action: [action_details]"

Context:
In the evolving landscape of software architecture, introducing new modules often necessitates revisiting and updating existing ones. This practice ensures optimal modularity and the extraction of common functionalities. ModuleB, being a newly developed model, may bring with it changes or enhancements that affect ModuleA. It's crucial to discern how ModuleB interacts or might interact with ModuleA, ensuring ModuleA requirements stay up-to-date.


Step AnalyzeAndDecideRelevance(category, specificationItem, moduleB_RequirementSpecification):
    Action: PRINT value of variable `category` and `specificationItem`. 
    moduleDescriptionOfModuleB = Action: Print the "Module Description" section of moduleB_RequirementSpecification
    Action: REASON whether specificationItem is functionally related to `moduleDescriptionOfModuleB` with confidence, Print the thinking process.

Step IdentifyRelevantItemsFromModuleAWithRespectToModuleB(moduleB_RequirementSpecification):
    FOR EACH category IN `4.1. Functional Specifications` AND `4.2. Technical Specifications` OF `[ModuleA]`:
        FOR EACH specificationItem under the category
            AnalyzeAndDecideRelevance(category, specificationItem, moduleB_RequirementSpecification)

Step AwaitUserToProvideModuleA():
   moduleA_RequirementSpecification = Action: Ask user to provide ModuleA requirement specification
   return moduleA_RequirementSpecification

Step AwaitUserToProvideModuleB():
   moduleB_RequirementSpecification = Action: Ask user to provide ModuleB requirement specification
   return moduleB_RequirementSpecification

EXECUTION PLAN:
   moduleA:moduleA_RequirementSpecification = AwaitUserToProvideModuleA()
   moduleB_RequirementSpecification = AwaitUserToProvideModuleB()
   IdentifyRelevantItemsFromModuleAWithRespectToModuleB(moduleB_RequirementSpecification)
END PROCEDURE




Version 3: This prompt is a lot more stable. It actually goes through every specification under every category. The output is also stabe. Even though the reasoning results are not correct.

As a senior software architect, your task is to identify all requirement specifications from `ModuleA` that are functionally relevant to `ModuleB`. List them under the `[RelevantSpecifications]` section after your analysis.

**Context**
In software engineering, module development is driven by requirements categorization or architectural enhancement. The introduction of a new module, `ModuleB`, may necessitate updates to an existing module, `ModuleA`, due to shared responsibilities, responsibility shifting, or integration needs. The requirement documentation for both modules provided in the `[ModuleA]` and `[ModuleB]` sections is written adhering to the requirement specification format defined by the template in the `[Template]` section, with requirement specifications listed under "4.1 Functional Requirements" and "4.2 Technical Requirements" headings. Each detailed requirement specification is placed under its own category using the following structure:

```
- **<Category_1>**:
   - <Specification_1.1>
   - <Specification_1.2>
   - ...
```

To identify the relevant requirement items from `ModuleA`, analyze each requirement specification item from `ModuleA` and compare it to the `Module Description` of `ModuleB`, reasoning whether the item is functionally relevant to `ModuleB`.

**Task Instructions**
1. Review each specification item under each category within the "4.1 Functional Requirements" and "4.2 Technical Requirements" sections sequentially from `ModuleA`.
2. Analyze each specification in all categories individually. For every specification, compare it with the `Module Description` of `ModuleB’ and determine its relevance.
3. Maintain a consistent approach across all categories. Ensure that each specification in every category is evaluated.
4. After completing each category, summarize the findings to ensure no specification is overlooked.
5. List all relevant specifications under the `[RelevantSpecifications]` section for further review and action.

**Required Output Format for Consistency**
Your analysis should follow this specific format for each requirement within each category:
```
Analysis of ModuleA Functional Requirements for Relevance to ModuleB
<Category Name>
  - <Specification Name>:
    ModuleB focuses on <ModuleB's relevant aspect>. <Relevance (Relevant/Not Relevant/Partially Relevant)> due to <brief reasoning>.

  - <Next Specification Name>:
    ModuleB's function includes <ModuleB's relevant aspect>. <Relevance (Relevant/Not Relevant/Partially Relevant)> because <brief reasoning>.

  ...

Continue in this manner for each specification within the category. After completing a category, move to the next one while maintaining the same format.
```

**Example Output:**
```
Analysis of ModuleA Functional Requirements for Relevance to ModuleB
Data Processing
  - Automate data aggregation from multiple sources:
    ModuleB focuses on data visualization, not aggregation. Not Relevant.

  - Apply real-time analytics to incoming data streams:
    ModuleB incorporates real-time data visualization, which complements this feature. Relevant.

  - Integrate advanced machine learning algorithms for data prediction:
    ModuleB's scope is limited to visualization without predictive capabilities. Not Relevant.

Security and Compliance
  - Implement end-to-end encryption for data transmission:
    ModuleB, being a visualization tool, does not handle direct data transmission. Not Relevant.

  - Ensure compliance with international data protection regulations:
    Both modules handle sensitive data. Compliance is essential for ModuleB as well. Relevant.

  ...

Continue this process for each category and specification.
```

**Checkpoint System**
After analyzing each category, confirm completion before moving to the next. This ensures thorough coverage of all specifications.







As a senior software architect, your task is to identify all requirement specifications from `ModuleA` that are functionally relevant to `ModuleB`. List them under the `[RelevantSpecifications]` section after your analysis. Your analysis must include meticulous reasoning and detailed comparison between the specifications of `ModuleA` and the `Module Description` of `ModuleB`.

**Context**
In software engineering, module development is driven by requirements categorization or architectural enhancement. The introduction of a new module, `ModuleB`, may necessitate updates to an existing module, `ModuleA`, due to shared responsibilities, responsibility shifting, or integration needs. The requirement documentation for both modules provided in the `[ModuleA]` and `[ModuleB]` sections is written adhering to the requirement specification format defined by the template in the `[Template]` section, with requirement specifications listed under "4.1 Functional Requirements" and "4.2 Technical Requirements" headings. Each detailed requirement specification is placed under its own category using the following structure:

```
- **<Category_1>**:
   - <Specification_1.1>
   - <Specification_1.2>
   - ...
```

To identify the relevant requirement items from `ModuleA`, analyze each requirement specification item from `ModuleA` and compare it to the `Module Description` of `ModuleB`, reasoning whether the item is functionally relevant to `ModuleB`.


**Task Instructions**
1. **Detailed Review and Comparison**: Review each specification item under the "4.1 Functional Requirements" and "4.2 Technical Requirements" sections of `ModuleA`. Compare each specification in detail with the `Module Description` of `ModuleB`.
2. **Emphasis on Detailed Reasoning**: For every specification, provide a detailed analysis of its relevance to `ModuleB`. Include specific references to `ModuleB's` description to substantiate your reasoning.
3. **Thorough and Consistent Analysis**: Ensure that each specification in every category is evaluated thoroughly and consistently.
4. **Periodic Review and Summary**: After analyzing each category, summarize the findings to ensure no specification is overlooked and the depth of analysis is adequate.
5. **Compilation of Relevant Specifications**: List all relevant specifications under the `[RelevantSpecifications]` section, formatted as per the guidelines below.

**Required Output Format for Consistency and Depth**
```
Detailed Analysis of ModuleA Functional Requirements for Relevance to ModuleB
<Category Name>
  - <Specification Name>:
    [In-depth reasoning linking to specific aspects of ModuleB’s description]. <Relevance (Relevant/Not Relevant/Partially Relevant)>.

  - <Next Specification Name>:
    [Detailed analysis with explicit reference to ModuleB's module description]. <Relevance (Relevant/Not Relevant/Partially Relevant)>.

  ...

[Continue this process for each specification within the category, ensuring comprehensive coverage and detailed analysis]
```

**Example of Detailed Analysis Output:**
```
Detailed Analysis of ModuleA Functional Requirements for Relevance to ModuleB
Data Processing
  - Automate data aggregation from multiple sources:
    Considering ModuleB’s role as [specific aspect from ModuleB's description], the automation of data aggregation is [Relevance] because [detailed reasoning with reference to ModuleB's description].

Security and Compliance
  - Implement end-to-end encryption for data transmission:
    Given ModuleB's involvement in [specific aspect from ModuleB's description], encryption is [Relevance] as it [detailed reasoning linking to ModuleB's responsibilities or functionalities].

  ...

[Ensure that each specification's analysis is as comprehensive and detailed as the examples provided]
```

**Checkpoint System**
After completing the analysis for each category, conduct a brief review to ensure you have thoroughly compared each specification with ModuleB's description and provided detailed reasoning for your conclusions. This checkpoint system ensures a high-quality, comprehensive analysis.

Now, please proceed with the task, adhering to the guidelines for a detailed and thorough analysis across all categories.


[Template]
### <Title> (Title should be closely related to the module, such as xxx Module Requirement Specification)

#### 1. Module Description:
Provide a concise description of the module, its purpose, and its technical significance.

#### 2. Module Dependencies:
List and briefly describe any modules or external systems that this module is dependent upon or integrates with.

- **<Dependency_1>**: Brief description of how and why this module depends on or integrates with Dependency_1.
- **<Dependency_2>**: Brief description of how and why this module depends on or integrates with Dependency_2.

<Continue listing dependencies as necessary.>

#### 3. Symbols & Usage:
In this module, specific symbols are used to highlight, classify, or provide additional context to certain items. This section explains the significance of each.

- **[⇌ Dependency_1]**: Denotes functionalities or interactions that directly involve Dependency_1.
- **[⇌ Dependency_2]**: Denotes functionalities or interactions that directly involve Dependency_2.

<Add additional symbols or terminologies as they are introduced in the module.>

#### 4. Specifications:

4.1. **Functional Specifications**:

- **<Category_1>**:
   - <Specification_1.1>
   - <Specification_1.2>
   - ...
   
- **<Category_2>**:
   - <Specification_2.1>
   - <Specification_2.2>
   - ...

<Continue listing categories and their associated specifications as necessary.>

4.2. **Technical Specifications**:

- **<Category_1>**:
   - <Specification_1.1>
   - <Specification_1.2>

<Continue listing categories and their associated specifications as necessary.>


[ModuleA]
### Automated Coding Workflow Module Requirements Specification

#### 1. Module Description:
This module facilitates the definition, management, and execution of a multi-step automated coding workflow. It encompasses functionalities to initialize workflow steps from configurations, convert workflow instances to JSON representations, and execute specific steps or the entire workflow.

#### 2. Module Dependencies:
- **LLM Integration Module**: This module utilizes the "LLM Integration Module" to interface with large language models like ChatGPT and execute coding instructions.

#### 3. Symbols & Usage:
- **[⇌ LLM Integration Module]**: Denotes functionalities or interactions that are directly tied to the LLM Integration Module.

#### 4. Specifications:

4.1. **Functional Specifications**:

- **Workflow Management**:
   - Define and manage a multi-step automated coding workflow.
   - Each step in the workflow can potentially have sub-steps.
   - [⇌ LLM Integration Module] Integrate with the "LLM Integration Module" to manage LLM communications.
   - Initialize steps of the workflow from a given configuration.
   - Convert the workflow instance to a JSON representation.
   - Start the entire workflow process.
   - Execute specific steps within the workflow using their ID.

- **Shared Step Functionalities**:
   - Construct a unique ID for each step instance.
   - [⇌ LLM Integration Module] Process the response from the "LLM Integration Module" for each step.
   - Define the execution logic for each step.
   - Construct a dynamic prompt for each step.

- **Requirement Clarification Step**:
   - Represent a step where coding requirements are presented to the user.
   - Define a default prompt template for this step.

- **Architecture Design Step**:
   - Represent the design stage in the coding workflow.
   - Define a default prompt template for this step.

4.2. **Technical Specifications**:
(No technical specifications were provided in the initial document. This section can be populated when such specifications are defined.)


[ModuleB]
### Prompt Versioning Module Requirements Specification

#### 1. Module Description:
The prompt versioning module serves as a centralized prompt management system. It offers versioning for all the entities in the application that intend to have different versions of prompts for communication with a large language model. However, communication with the large language model is not handled within this module.

#### 2. Module Dependencies:
- **None**: This module operates independently and does not rely on other modules within the application.

#### 3. Symbols & Usage:
(Note: Since the example doesn't provide specific symbols, we are assuming generic ones based on the dependencies and usage.)
- **[⇌ Independent]**: Denotes functionalities or interactions that are managed internally without relying on other modules.

#### 4. Specifications:

4.1. **Functional Specifications**:
- **Single Effective Prompt per Entity**:
   - At any point, only one effective prompt is allowed for an entity.
   - Users (such as other backend systems or APIs) can designate any archived version as the current effective prompt, superseding the prior effective prompt.

- **Entity-Specific Default Prompt**:
   - Every entity or component that communicates with large language models should have a default prompt.
   - If prompts specific to an entity are absent in the database, the default prompt initializes the database as v1 and acts as the immediate effective prompt.

- **Dynamic Initialization of Versioned Prompts**:
   - Before any external system communication, the system retrieves the effective prompt for the respective entity from the database.
   - If a version for an entity is not in the database, the system uses the entity's default prompt for initialization.

- **Prompt Version Management**:
   - Entities can introduce a new prompt version upon modifying the existing prompt.
   - A maximum of 4 prompt versions are maintained for each entity.
   - If a new version exceeds the 4-version cap, the oldest version is purged.

- **Database Management**:
   - Versions are depicted using simple incremented

4.2. **Technical Specifications**:
(No technical specifications were provided in the initial document. This section can be populated when such specifications are defined.)
