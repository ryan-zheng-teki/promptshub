# Version 2
You are a python software architect. You are given a software requirements and 
system design documentations between `$start$` and `$end$` at [Documentation] section. Your goal is to create subtasks.

Each task should follow the criterias.
Criterias:
- Clear Objective: Clearly state what needs to be achieved, such as creating a class, method, or implementing a specific algorithm.
- File Specification: Indicate the exact file (with path) where the code should be added or modified. Follow python clean code best practices to create folders and file names. Each class will be put in its own file.
- Functionality Details: Describe what the code should accomplish once executed, such as expected behavior, return types, or interaction with other components.
- Integration Points: Mention any interactions with other parts of the codebase, highlighting dependencies or interfaces.


Enclose each task created betwen `#task start#` and `#task end#` tokens.

Think step by step methodically and reason comprehensively. 


[Context]
- place all the files inside tools folder.

[Documentation]
#start#
### Requirements Documentation

#### 1. Story/Feature Description:

1.1. **Background**: 
In the realm of AI, an AI Agent is developed to modify files based on specific outputs. Given potential inaccuracies and uncertainties associated with these outputs, a safe mechanism for these modifications is vital. Instead of committing changes immediately, the system should allow users to review and then decide whether to accept or reject the changes. If approved, the changes persist; if declined, the system programmatically reverts the files to their original state. This mechanism ensures user confidence and reduces the risk of unintentional alterations. Additionally, with the integration of real-time event monitoring and operation journaling, users can now observe and trust the operations as they are being executed, providing an enhanced layer of transparency and trust.

1.2. **User Persona**: 
AI Agent User (Developer, System Administrator) who needs to:
  - Execute transactional operations.
  - Review changes made by AI.
  - Decide to commit or rollback operations.
  - Receive real-time updates on operations.
  - Trust in the system's ability to recover from unexpected issues.

1.3. **User Journey**: 
A user instructs the AI Agent to make modifications. Post-operation, a review process is initiated, giving the user a summary of changes. As operations are executed, they are journaled, allowing for recovery in case of unexpected issues. The user can trust that the system has a mechanism for accurately capturing every action. Real-time updates are provided, allowing users to monitor the system's actions closely. Post-review, the user either commits the changes if satisfactory or rolls them back if not. The system ensures a rollback reverts all changes, restoring the system to its pre-operation state.

#### 2. Requirements:

2.1. **Functional Requirements**:

- **File Operations**:
   - Reading from files.
   - Writing to files.
   - Appending to files.
   - Renaming files.
   - Deleting files.

- **Shell Operations**:
   - Running shell commands to install or uninstall libraries/packages.
   - Executing other miscellaneous shell commands.

- **Journaling**:
   - Recording every operation in a journal file.
   - Ability to replay operations from a journal.
   - Ability to rollback operations using the journal.
   - Recovery mechanism using uncommitted journals after system restarts.

- **Transaction Lifecycle**:
   - **Start Transaction**: Start every transaction with initialization.
   - **Execute Operations**: Execute the required operations within the transaction and log them.
   - **User Review**: Allow the user to review the changes.
   - **Commit or Rollback**: Based on the user's decision, either commit or rollback all executed operations using the journal.
   - **End Transaction**: Gracefully terminate the transaction.

- **Real-Time Monitoring**: Users can monitor operations in real-time, providing transparency and confidence in the system's actions.
   - **Operation Events**: Emit real-time events for every operation executed or undone. 
   - **Event Streaming**: Emit events for operation states and stream them in real-time to the frontend, allowing users to track the progress and actions of the AI agent.

---

### System Design Documentation

#### 1. System Design:

1.1. **High-Level Design**: 
The design follows the Command Pattern, encapsulating each operation within a command object. This approach simplifies execution and potential reversion. Event production and buffering mechanisms support frontend integration via real-time updates. A relationship between the `JournalManager` and `OperationEventProducer` ensures every significant operation is both journaled for recovery and emitted as an event for real-time feedback.

1.2. **Component Descriptions**:

- **Operation**: Represents an action to be executed. Each operation has methods to perform and potentially undo the action.
  
- **OperationEventProducer**: Emits events for various operation states, which frontend services can consume.

- **JournalManager**: Manages the journaling of operations for recovery purposes. It also interacts with the `OperationEventProducer` to emit real-time events every time an operation is journaled.

- **OperationEventBuffer**: Temporarily stores recent events for frontend services that might have missed real-time updates.

- **OperationExecutor**: Manages the execution and potential reversion of operations.
  
- **Handlers**: Perform the actual operations. For instance, `ShellHandler` for shell commands.
  
- **OperationLifecycleManager**: Manages the transaction lifecycle, including starting, committing, and rolling back transactions.
  
- **BackupHandler**: Manages backups for file operations, allowing for a rollback feature.

1.3. **Interactions**: 
The AI Agent creates and initializes operations. These operations are executed by the `OperationExecutor`. As operations progress, events are emitted by the `OperationEventProducer` and captured in the `OperationEventBuffer`. The frontend can then access these events for real-time updates. The `JournalManager` collaborates with the `OperationEventProducer` to ensure that every journaled operation is also emitted as a real-time event.

1.4. **External Dependencies**: 
None identified currently.

#### 2. UML Diagrams:


@startuml

package "Operation Module" {
    class Operation {
        + execute()
        + undo()
        + to_dict(): dict
        + from_dict(data: dict): Operation
    }
    
    class FileOperation {
        + execute()
        + undo()
        + to_dict(): dict
        + from_dict(data: dict): FileOperation
    }
    
    class FileRenameOperation {
        + execute()
        + undo()
        + to_dict(): dict
        + from_dict(data: dict): FileRenameOperation
    }
    
    class ShellOperation {
        + execute()
        + undo()
        + to_dict(): dict
        + from_dict(data: dict): ShellOperation
    }
}

package "Operation Executor Module" {
    class OperationExecutor {
        + add_operation(operation: Operation)
        + execute_operations(transaction_id: str)
        + rollback_operations()
    }
    
    class JournalManager {
        + initialize_journal(transaction_id: str)
        + record_operation(operation: Operation)
        + finalize_journal(transaction_id: str, status: str)
    }
    
    class OperationEventProducer {
        + emit_event(event: str)
    }
}

cloud "Handlers" {
    class ShellHandler {
        + handle_operation(operation: ShellOperation)
    }
}

database "Coordinator and Backup" {
    class OperationLifecycleManager {
        + start_transaction(): str
        + rollback(transaction_id: str)
        + commit(transaction_id: str)
    }
    
    class BackupHandler {
        + create_backup(transaction_id: str, filepath: str)
        + restore_backup(transaction_id: str, filepath: str)
    }
    
    class TransactionLogger {
        + log_transaction_activity(activity: str)
    }
    
    class BackupLogger {
        + log_backup_activity(activity: str)
    }
    
    class OperationEventBuffer {
        + add_event(event)
        + get_recent_events()
    }
    
    note right of OperationLifecycleManager: "Manages the transaction\nlifecycle and logs activities"
    note bottom of BackupHandler: "Handles backups before operations\nand restores them if needed"
}

[AI Agent] -down-> OperationExecutor: Invokes operations

note over AI Agent: User interacts primarily\nwith the AI Agent to\ninitiate operations

OperationExecutor --> JournalManager: Logs and journals operations
OperationExecutor --> OperationEventProducer: Emits events

ShellOperation --> ShellHandler: Executes shell commands

OperationLifecycleManager --> TransactionLogger: Logs transaction activities
BackupHandler --> BackupLogger: Logs backup activities
OperationEventProducer --> OperationEventBuffer: Sends events

@enduml
#end#
  