You are a Python software architect. Based on the Python source code provided in the `[SourceCode]` and the context provided in the `[Context]` sections, your task is to reverse engineer the feature code design documentation.

Criteria:
- The final documentation should follow the format defined in the `[Template]` section.
- The final documentation should be placed in a copiable code block.

Think step by step meticously before output the final documentation. 

[Template]
### Feature Code Design Documentation Template:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
- Brief overview of the primary architecture.
- Design patterns, principles, or architectures that will be applied.

1.2. **Components Modifications**:

- **New Components**:
For each component:
  - **Name (New) [extends/relates OtherComponentName]** (if applicable)
    - **Purpose**: Clear description of the component's role and functionality.
    - **Attributes**:
      - `attribute_name`: Short description of the attribute and its significance.
      ... Continue for all attributes.
    - **Methods/APIs**:
      - `method_name()`: Describe the method's purpose, expected input, and output.
      ... Continue for all methods.
    - **Interactions**: Describe how this component interacts with other components.

... Continue for all new components.

- **Updated Components**:
For each component:
  - **Name (Existing/Updated) [extends/relates OtherComponentName]** (if applicable)
    - **Purpose**: Clear description of the component's role and functionality.
    - **Updates/Changes**: Any alterations or extensions to the existing component.
    - **Interactions**: Describe how this component interacts with new components or any changes in its interactions with existing components.

... Continue for all updated components.

- **Dependencies (Unchanged Components)**:

For each component:
  - **Name (Existing)**
    - **Purpose**: Clear description of the component's role and functionality.
    - **Interactions**: Describe its interactions, if necessary.

... Continue for all dependencies.

1.3. **Interactions Overview**: 
- A broader perspective on how new components interact with each other and with existing components.
- Any sequence of operations or workflows that need to be followed.

1.4. **External Dependencies**: 
- List any third-party libraries, services, or tools that will be used.
- Specific versions or configurations to be aware of.

#### 2. UML Diagram:

- Attach the UML diagram showcasing the relationships and interactions between components.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing/Updated)` have been modified or extended.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

@startuml
... UML content here ...
@enduml

[Example]
### Example:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
This feature is designed to implement the Observer Pattern, enabling multiple subscribers to be notified of certain events. The architecture ensures that event initiators and responders are decoupled, allowing for modularity and scalability.

1.2. **Components Modifications**:

- **New Components**:
  - **Publisher (New)**
    - **Purpose**: Acts as the broadcaster for events. It notifies all subscribers when an event occurs and logs them to the `EventDatabase`.
    - **Attributes**:
      - `subscribers_list`: List storing all the registered subscribers.
    - **Methods/APIs**:
      - `trigger_event()`: Initiates an event, logs it, and notifies subscribers.
      - `add_subscriber(subscriber: Subscriber)`: Adds a new subscriber to the subscribers list.
      - `log_event_to_database(event: Event)`: Logs the event to the `EventDatabase`.
    - **Interactions**: Connects with the `EventDatabase` to log events and communicates with `Subscriber` entities to notify them of events.

  - **Subscriber (New) [relates Publisher]**
    - **Purpose**: Monitors and responds to particular events triggered by the `Publisher`.
    - **Attributes**:
      - `event_history`: List to store received events.
    - **Methods/APIs**:
      - `on_event_received(event: Event)`: Handles the event and stores it in `event_history`.
    - **Interactions**: Receives event notifications from the `Publisher`.

- **Dependencies (Unchanged Components)**:
  - **EventDatabase (Existing)**
    - **Purpose**: A database component designed to store all triggered events.

1.3. **Interactions Overview**: 
- Users or systems interface with the `Publisher` to initiate events.
- Once an event is triggered, the `Publisher` logs the event to the `EventDatabase`.
- The `Publisher` then notifies all `Subscriber` entities of this event.

1.4. **External Dependencies**: 
- None.

#### 2. UML Diagram:

@startuml

class "Publisher (New)" {
    + subscribers_list: List[Subscriber]
    + trigger_event()
    + add_subscriber(subscriber: Subscriber)
    + log_event_to_database(event: Event)
}

class "Subscriber (New)" {
    + event_history: List[Event]
    + on_event_received(event: Event)
}

class "EventDatabase (Existing)" {
    + save_event(event: Event)
}

"Publisher (New)" --> "Subscriber (New)": Event notification
"Publisher (New)" --> "EventDatabase (Existing)": Logs event

@enduml

[SourceCode]



As a Python software architect, you are tasked with creating design documentation for a feature based on provided Python source code. Your objective is to analyze the code, discern its role in the feature's architecture, and generate a part of the feature's design documentation.

**Criteria**:
- Analyze the source code provided in the `[SourceCode]` section.
- Determine the primary focus and context of the feature from the class/module, considering naming conventions and imported packages/classes.
- For the context of this task, classes/modules directly related to the primary focus of the feature (e.g., automated coding workflow) should be treated as new.
- Only components that seem external or unrelated to the core feature should be considered existing.
- Create documentation that aligns with the format in the `[Template]` section.
- Design a PlantUML diagram representing the architecture, ensuring it follows the PlantUML syntax. Use notes inspired by the example in `[Example]`.

**Background**:
The development process for this new feature requires comprehensive design documentation before actual development. The provided code represents what the final implementation might look like. Your job is to visualize and document the architecture of this feature based on the provided code.

**Steps**:
1. **Analyze the Code**: Understand its purpose, functionality, and potential relationships. Pay close attention to naming conventions and imports.
2. **Feature Context**: Determine the primary focus of the feature. Identify any hints from imported classes/packages that might be part of the feature.
3. **Document**: Draft the design documentation according to the `[Template]` format.
4. **UML Diagram**: Construct a PlantUML diagram that offers a visual representation of the class/module within the feature's architecture.
5. **Review**: Ensure the documentation and UML diagram capture the broader context and meet the provided criteria.

Your meticulous approach is key to capturing the essence of the feature and its architecture comprehensively.


[SourceCode]
$start$
$end$




You are a Python software architect. Your task is to analyze Python source code to discern the architecture and design of a software feature. Based on your analysis, craft a feature architecture design documentation complemented with a PlantUML diagram.

### Criteria:
- Analyze the Python source code provided in `[SourceCode]`.
- The final design documentation should adhere to the format in the `[Template]` section.
- Ensure the UML diagram within the documentation follows PlantUML syntax and includes explanatory notes, as shown in `[Example]`.
- Present the completed documentation in a copiable code block.


### Approach:
1. Analyze the Code: Comprehend the code's primary purpose. Identify key classes, methods, and their interrelations.
2. Determine Feature Boundaries: Decide on the central classes and components of the feature. Recognize if imported classes are part of the feature. 
3. Craft the Documentation: Use the `[Template]` to document the architecture.
4. Design the UML Diagram: Visualize the architecture using PlantUML, ensuring clarity and conciseness.
5. Finalize & Re-evaluate: Review the documentation and diagram. Revisit your observations if needed, ensuring alignment with the feature's core.

Think meticulously and step-by-step to produce a comprehensive and insightful documentation.

[Template]

[SourceCode]
$start$
$end$


As a Python-focused software architect, you're tasked with crafting design documentation for a specific feature using its source code.

**Background:**
The provided source code is a portion of a larger feature. Not all modules related to this feature are available. Your objective is to incrementally draft retroactive documentation based on this existing code, identifying its main components while distinguishing them from external dependencies.

**Criteria:**
- Adhere to the format outlined in the `[Template]` section.
- Ensure your UML diagram aligns with the PlantUML syntax. It should also be accompanied by explanatory notes, akin to the `[Example]` section.
- Provide your final documentation in a format that can be easily copied.

**Approach:**
1. Thoroughly analyze the source code to grasp the feature's main objective and context.
2. Identify classes or modules that are directly related to the feature's main objective. Treat these as new components. Use class or package names as indicators.
3. Consider components that seem unrelated to the feature's core as existing external dependencies.

Ensure you approach this task methodically and reason through each step.


You are a Python software architect. Your responsibility is to reverse-engineer the given code back to feature code design.(Not correct)

### Background
- In software engineering, standard process follows feature requirement, feature code design, subtask creation, subtask implementation sequence. However, due to management issues, the standard process was not followed. The code was implemented without feature code design documentation. Now we need to retroactively to
create the feature code design documentation based on given code incrementally.

### Criteria:
- Final documentation should follow the format specified in the `[Template]` section.
- Final documentation should include a UML diagram following PlantUML syntax. Refer to the `[Example]`
- Present your finalized design documentation in a copiable code block.

### Steps:
1. Understand the source code given in the [SourceCode] section. 
2. Summarize what feature this code segment could be trying implement.
3. Analyse each dependency functionality under package `autobyteus`. Try to analyze whether it's 'part-of' the feature or it's 'used-by' the feature. When the dependencies are under the same package as the package in the source code, then they are 'part-of' dependencies. Otherwise, they are 'used-by' dependencies.
4. Based on previous analysis steps, start compiling the design documentation. Treat 'part-of' dependencies as new components and 'used-by' dependencies as existing ones.

Please follow the `Steps` defined, ensure a meticulous approach and comprehensive reasoning for each step.

[Template]

[Example]

[SourceCode]


You are a Python software architect tasked with reverse-engineering a given piece of code to craft its design documentation.

### Criterias:
- The final documentation should adhere to the format given in the `[Template]` section.
- The final design documentation should be placed within a copiable code block.

### Procedure:
1. Understand the source code in the [SourceCode] section.
2. Deduce the probable feature this code aims to implement.
3. Analyse each project package dependency (excluding standard third-party packages). Determine if it's a 'part-of' or 'used-by' the feature. Dependencies within the same package as the source code are considered 'part-of' the feature, while others are 'used-by' dependencies.
4. List all the part-of dependencies, and used-by dependencies.
5. Based on your analysis, begin drafting the design documentation. Treat all 'part-of' dependencies as new components and 'used-by' dependencies as existing ones.

Follow the steps defined in 'Procedure' section, think meticously and reason comprehensively for each step.



You are a Python software architect tasked with reverse-engineering a given piece of code to craft its design documentation. Not all the codes related to the feature is provided, so you have to guess whether a certain project dependency possibly belongs to the feature, but the code is not yet provided. 

### Criterias:
- The final documentation should adhere to the format given in the `[Template]` section.
- The final design documentation should be placed within a copiable code block.

### Procedure:
1. Understand the source code in the [SourceCode] section.
2. Deduce the probable feature this code aims to implement.
3. Analyse each project package dependency. Analyse could this dependency belong to the same feature, but just the code is not provided. Based on your rating, mark this dependency as either 'part-of' or 'used-by' dependeny.
5. Based on your analysis, begin drafting the design documentation. Treat all 'part-of' dependencies as new components and 'used-by' dependencies as existing ones.

Follow the steps defined in 'Procedure' section, think meticously and reason comprehensively for each step.


You are a Python software architect. Your task is to progressively reverse-engineer code files to assemble design documentation for an entire feature. Files will be provided one at a time due to your limited context size. You will continually evolve the code design documentation with each additional file.

### Criteria:
- Ensure the design documentation is consistent with the `[Template]` section, Continue adapt the documentation with each additional file.
- Present the design documentation in a copiable code block.

### Procedure:
1. **Review the Source Code**:
    - Thoroughly examine the provided code file in the [SourceCode] section. As you review, make preliminary notes on key functionalities and structures.

2. **Identify File's Role and Dependencies**:
    - Determine the primary function or role of the file within the larger feature's context.
    - Identify and classify each project package dependency within the file:
      - If it's directly related to the feature and its code is not provided, label it as 'part-of'.
      - If it's an auxiliary or external tool/service supporting the feature, label it as 'used-by'.

3. **Draft and Update the Documentation**:
    - Based on insights from the file and its dependencies, draft the corresponding section of the design documentation. List 'part-of' dependencies as new components, leaving details empty. Fill in the specifics when you get the related code.

Follow the steps defined in 'Procedure' section, think meticously and reason comprehensively for each step.

[Template]


[Example]
### Example:




[SourceCode]
"""
autobyteus/prompt/prompt_template.py

This module contains the PromptTemplate class, which represents a prompt that may contain various template variables.

PromptTemplate class features:
- The raw template string.
- A list of associated PromptTemplateVariable instances.
- A method to convert the prompt template to a dictionary representation for frontend communication.
"""

from autobyteus.prompt.prompt_template_variable import PromptTemplateVariable


class PromptTemplate:
    def __init__(self, template: str, variables: list[PromptTemplateVariable] = None):
        self.template = template
        self.variables = variables if variables is not None else []

    def to_dict(self) -> dict:
        """
        Converts the PromptTemplate instance to a dictionary representation.

        Returns:
            dict: Dictionary representation of the PromptTemplate instance.
        """
        return {
            "template": self.template,
            "variables": [variable.to_dict() for variable in self.variables]
        }
    
    def fill(self, values: dict) -> str:
        """
        Fill the template using the provided values.

        Args:
            values (dict): Dictionary containing variable names as keys and their respective values.

        Returns:
            str: The filled template string.
        
        Raises:
            KeyError: If a required variable is missing from the provided values.
        """
        try:
            return self.template.format(**values)
        except KeyError as e:
            raise KeyError(f"Missing value for template variable: {e}")






### Enhanced Feature Code Design Documentation Template:

#### 1. Code Architecture Design:

1.1. **High-Level Design**:
- Outline of the primary architectural concepts.
- Listing of design patterns, principles, or structures to be used.

1.2. **Components Modifications**:

- **Fully Defined New Components**:
For each component:
  - **Name (New) [extends/relates OtherComponentName]** (if applicable)
    - **Purpose**: Description of the component's role and tasks.
    - **Attributes**:
      - `attribute_name`: Detail about the attribute.
      ... Continue for all attributes.
    - **Methods/APIs**:
      - `method_name()`: Explanation of the method's function.
      ... Continue for all methods.
    - **Interactions**: How this component relates to others.

... Continue for all new components.

- **Placeholder Components**:
For each component:
  - **Name (Placeholder) [extends/relates OtherComponentName]** (if applicable)
    - **Status Note**: _"Component identified as part of the feature, but specific details not provided. Information will be enhanced later."_
    - **Purpose**: Tentative description of the component's role and tasks (if discernible).
    ... Potentially some high-level attributes or methods, but these would be quite general until specific details are provided.

... Continue for placeholders.

- **Updated Components**:
For each component:
  - **Name (Existing/Updated) [extends/relates OtherComponentName]** (if applicable)
    ... (rest of the structure as in the previous versions, without a Status Note)

- **Dependencies (Unchanged Components)**:
For each component:
  - **Name (Existing)**
    ... (rest of the structure as in the previous versions, without a Status Note)

1.3. **Interactions Overview**:
... (as in your original template)

1.4. **External Dependencies**:
... (as in your original template)

#### 2. UML Diagram:

... (as in your original template)
