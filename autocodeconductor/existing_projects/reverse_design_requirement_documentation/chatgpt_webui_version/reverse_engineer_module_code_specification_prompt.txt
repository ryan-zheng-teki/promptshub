Version 1: The role is Python architect. 
You are a Python architect. You are tasked with initiating the module code specification documentation for an already-implemented module. Given the context size constraints, you'll only be able to handle one file at a time. Use this file to start the documentation.

### Context:
- "Part-Of" components refer to elements likely part of the same module, but their code isn't provided in the `[SourceCode]` section.
- "Used-By" components describe elements supporting the current module, but their direct contribution might be unclear.

### Criteria:
- Base your documentation on the format defined by the template in the `[Template]` section.
- Present the documentation in a copiable block.

### Procedure:
1. **Review the Source Code**: Identify its main functionalities.
2. **Establish the File's Purpose and Dependencies**:
   - Understand the file's primary purpose within the overarching module.
   - Identify non-third-party dependencies within the same root package and answer:
      - What function might this dependency serve?
      - Does the suspected function of the dependency directly contribute to the module? If its functionality is unclear or its contribution to the module is indirect or not part of the module, label it as `Used-By`. Otherwise, label it as `Part-Of` and state its potential function. The response format should be: 'The dependency's functionality is __, and it serves as __. Label it as `Part-Of`. If its role is uncertain, label it as `Used-By`.

3. **Compose the Documentation**: Draft the design documentation based on previous insights, refer to the `[Example]` section for guidance.

Follow the steps defined in the 'Procedure' section. Take a deep breath, think step by step, and reason comprehensively for each step.

[Template]
### Module Code Specification Template:

#### 1. Module Architecture Design:

##### 1.1. High-Level Design
- Brief overview of the primary module architecture.
- Design patterns, principles, or structures that will be applied.

##### 1.2. New Components Specifications

###### 1.2.1. Fully Defined
For each component:
  - **Name (New) [extends/relates OtherComponentName]** (if applicable)
    - **Purpose**: Clear description of the component's role and functionality within the module.
    - **Attributes**:
      - `attribute_name`: Short description of the attribute and its significance.
      ... Continue for all attributes.
    - **Methods/APIs**:
      - `method_name()`: Describe the method's purpose, expected input, and output.
      ... Continue for all methods.
    - **Interactions**: Describe how this component interacts with other module components.

... Continue for all fully defined new components.

###### 1.2.2. Part-Of Components (Pending File Provision)
For each component:
  - **Name (Part-Of) [extends/relates OtherComponentName]** (if applicable)
    - **Status Note**: _"This component is part of the module, but its detailed specifications will be supplemented upon provision of the relevant file."_
    - **Tentative Purpose**: A general understanding or assumption about the component's role and tasks based on current knowledge.

... Continue for placeholders.

##### 1.3. Used-By Dependencies (Unchanged Components)

For each component:
  - **Name (Used-By)**
    - **Purpose**: Clear description of the component's role and functionality within the module.
    - **Interactions**: Describe its interactions with new module components, if any.

... Continue for all dependencies.

##### 1.4. Interactions Overview
- A broader perspective on how new module components interact with each other and with existing components.
- Highlight any specific sequence of operations or workflows within the module.

##### 1.5. External Dependencies
- List any third-party libraries, services, or tools that the module will use.
- Specific versions or configurations to be aware of.

#### 2. UML Diagram

- A UML diagram showcasing the relationships and interactions between module components.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this module.
  - Components marked with `(Part-Of)` are identified but not fully defined within the module.
  - Components marked with `(Used-By)` are pre-existing and are treated as dependencies within the module context.

@startuml
... UML content here ...
@enduml


[Example]



[SourceCode]


Version 2: The role is language model, but performing as a python software architect.
$start$
You are a large language model performing as a Python architect. You are tasked with initiating the module code specification documentation for an already-implemented module. Given the context size constraints, you'll only be able to handle one file at a time. Use this file to start the documentation.

### Context:
- "Part-Of" components refer to elements likely part of the same module, but their code isn't provided in the `[SourceCode]` section.
- "Used-By" components describe elements supporting the current module, but their direct contribution might be unclear.

### Criteria:
- Base your documentation on the format defined by the template in the `[Template]` section.
- Present the documentation in a copiable block.

### Procedure:
1. **Review the Source Code**: Identify its main functionalities.
2. **Establish the File's Purpose and Dependencies**:
   - Understand the file's primary purpose within the overarching module.
   - Identify non-third-party dependencies within the same root package and answer:
      - What function might this dependency serve?
      - Does the suspected function of the dependency directly contribute to the module? If its functionality is unclear or its contribution to the module is indirect or not part of the module, label it as `Used-By`. Otherwise, label it as `Part-Of` and state its potential function. The response format should be: 'The dependency's functionality is __, and it serves as __. Label it as `Part-Of`. If its role is uncertain, label it as `Used-By`.

3. **Compose the Documentation**: Draft the design documentation based on previous insights, refer to the `[Example]` section for guidance.

Follow the steps defined in the 'Procedure' section. Take a deep breath, think step by step, and reason comprehensively for each step.



Second Prompt: Refining and Expanding the Design Documentation

You are a Python architect. Your task is to refine and expand the feature code design documentation provided in the `[InitialFeatureCodeDesign]` for an already-implemented feature. Given the context size constraints, you can handle one file at a time. Use the provided file to update the initial documentation. The code is given in the `[SourceCode]` section.

### Context:
- The goal is to further develop the documentation, potentially transitioning components from the "Placeholder" section to "Fully Defined" if the associated code is now provided.
- Ensure the updated documentation maintains consistency with the initial one.

### Criteria:
- The revised documentation must adhere to the `Feature Code Design Documentation Template` provided in the `[Template]` section.
- The updated documentation should be presented in a copiable code block.

### Procedure:
1. **Review the Source Code**:
   - Scrutinize the code file in the `[SourceCode]` section, identifying primary functionalities and structures.

2. **Determine the File's Main Component**:
   - Establish the main role of the file within the feature's broader context.
   - If the main component of the file matches a "Part-Of" in the given documentation, move it to the "Fully Defined" section and supply its complete details.

3. **Assess Dependencies**:
   - Identify non-third-party dependencies within the same root package and answer:
      - Is the component already defined as "Fully Defined" in the given documentation. If yes, no further action is needed.
      - What function might this dependency serve?
      - Does the suspected function of the dependency directly contribute to the feature? If its functionality is unclear or its contribution to the feature is indirect or not part of the feature, label it as `Used-By`. Otherwise, label it as `Part-Of` and state its potential function. The response format should be: 'The dependency's functionality is __, and it serves as __. Label it as `Part-Of`. If its role is uncertain, label it as `Used-By`.
4. **Update and Refine the Documentation**: Based on the insights from previous analysis, update the existing design documentation, refer to the `[Example]` section for guidance.


You are a Python architect. You're tasked with refining a given initial feature code design documentation in the `[InitialFeatureDesign]` based on the additional given source code in the `[SourceCode]` section.

### Criteria:
- Ensure the refined documentation aligns with the initial one.
- Follow the `Feature Code Design Documentation Template` provided in the `[Template]` section.
- Present the refined documentation in a copiable code block. Do not use placeholders to ensure easy direct overritting.

1. **Review the `[SourceCode]` Section**: Understand its primary functionalities.
2. **Identify the File's Role**: If it aligns with any "Part-Of" in the documentation, move it to "Fully Defined" and detail it.
3. **Check Dependencies**: For non-third-party dependencies:
   - If it's already "Fully Defined", skip.
   - Otherwise, determine its function.
   - Label as `Part-Of` if it directly contributes to the feature, detailing its function. If unclear, label as `Used-By`.
4. **Refine the Documentation**: Update the given design documentation with the insights gained from previous steps. Use example provided by `[Example]` for guidance.

Follow the steps defined in 'Procedure' section. Take a deep breath, think step by step and reason comprehensively for each step.


[Template]


[Example]


[InitialFeatureDesign]


[SourceCode]


Well done. Thank you. Could you please give me back the complete updated documentation, so that the Agent program can directly override the existing one 
in database?





