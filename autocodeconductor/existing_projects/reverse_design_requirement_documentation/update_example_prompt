You are a large language model performing as a software architect tasked with updating an existing module code design example. The original template, from which the example was derived, has undergone changes, and it is crucial to align the example with the updated template while ensuring its functionality.

**Criteria**:
1. Reflect the changes made in the updated template accurately in the example.
2. Preserve the coherence and functionality of the example.
3. Avoid unnecessary overhauls; the primary focus should be alignment with the template.

**Procedure**:
1. Thoroughly study the updated template provided in the `[Template]` section to grasp its format and structure.
2. Cross-check the existing module code design example given in the `[Example]` section against the updated template.
3. Pinpoint the segments in the example that need adjustments based on the template's updates.
4. Implement the required changes in the example while maintaining its overall coherence. And present the implemented new example in a copiable code block.


[Template]:
### <Title> (Title should be closely related to the module, such as xxx Module Requirements Specification)

#### 1. Module Description:
Provide a concise description of the module, its purpose, and its technical significance.

#### 2. Module Dependencies:
List and briefly describe any modules or external systems that this module is dependent upon or integrates with.

- **<Dependency_1>**: Brief description of how and why this module depends on or integrates with Dependency_1.
- **<Dependency_2>**: Brief description of how and why this module depends on or integrates with Dependency_2.

<Continue listing dependencies as necessary.>

#### 3. Symbols & Usage:
In this module, specific symbols are used to highlight, classify, or provide additional context to certain items. This section explains the significance of each.

- **[⇌ Dependency_1]**: Denotes functionalities or interactions that directly involve Dependency_1.
- **[⇌ Dependency_2]**: Denotes functionalities or interactions that directly involve Dependency_2.

<Add additional symbols or terminologies as they are introduced in the module.>

#### 4. Specifications:

4.1. **Functional Specifications**:

- **<Category_1>**:
   - <Specification_1.1>
   - <Specification_1.2>
   - ...
   
- **<Category_2>**:
   - <Specification_2.1>
   - <Specification_2.2>
   - ...

<Continue listing categories and their associated specifications as necessary.>

4.2. **Technical Specifications**:

- **<Category_1>**:
   - <Specification_1.1>
   - <Specification_1.2>

<Continue listing categories and their associated specifications as necessary.>



[Example]

### Prompt Versioning Mechanism Requirements Specification

#### 1. Module Description:

This module manages versioned prompts. It provides foundational functionality for entities to handle prompt variations. Central to this module is an Abstract Entity designed to be extended by other entities desiring prompt versioning capabilities. While the module focuses on prompt management, it does not oversee direct communication with external systems by the entities.

#### 2. Module Dependencies:
- **None**: This module operates independently and does not rely on other modules within the application.

#### 3. How To Use This Module:
- Entities wishing to utilize prompt versioning must extend the provided Abstract Entity.
- The Abstract Entity defines a default prompt that must be overridden by extending entities to suit their specific needs.
- Once an entity extends the Abstract Entity, the module automatically manages the creation, management, and retrieval of versioned prompts for that entity.

### Why Do we Have This Module, It's Purpose
During more clear understanding of our requirements, we found that we want to have 
prompt versioning capabilities for each entity in other modules which need to communicate 
with large language module. The prompt versioning capabilities includes:

#### 4. Specifications:

4.1. **Functional Specifications**:

- **Single Effective Prompt per Entity**:
   - At any point, only one effective prompt is allowed for an entity.
   - Users (such as other backend systems or APIs) can designate any archived version as the current effective prompt, superseding the prior effective prompt.

- **Entity-Specific Default Prompt**:
   - Every entity or component that communicates with external systems and extends the Abstract Entity must override its default prompt.
   - If prompts specific to an entity are absent in the database, the overridden default prompt initializes the database as v1 and acts as the immediate effective prompt.

- **Dynamic Initialization of Versioned Prompts**:
   - Before any external system communication, the system retrieves the effective prompt for the respective entity from the database.
   - If a version for an entity is not in the database, the system uses the entity's overridden default prompt for initialization.

- **Prompt Version Management**:
   - Entities can introduce a new prompt version upon modifying the existing prompt.
   - A maximum of 4 prompt versions are maintained for each entity.
   - If a new version exceeds the 4-version cap, the oldest version is purged.

- **Database Management**:
   - Versions are depicted using simple incremented numerals (e.g., v1, v2, etc.).
   - Each version's creation/modification timestamp is documented.

4.2. **Technical Specifications**:

- **Database Interaction**:
   - Efficient CRUD (Create, Read, Update, Delete) operations for prompt version management are paramount.
   - Versions are recorded with unique identifiers, timestamps, and version numbers.
```

Please follow the steps defined in the Procedure. Ensure meticulous step-by-step thinking and comprehensive reasoning for each step.


