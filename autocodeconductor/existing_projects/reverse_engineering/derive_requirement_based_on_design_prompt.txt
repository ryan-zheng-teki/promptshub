Version 1:
You are software architect. Based on the feature code design documentation provided in the `[CodeDesignDoc]` section, your task is to generate feature requirement documentation that represent the feature requirements that the code design is based on. The content of each section is enclosed between `$start$` and `$end$` tokens.

### Background
Previously our development te`am didn't follow the standard process to create feature requirement documentation. But they created the feature code design documentation. Now we are reverse engineering the requirement documentation based on the feature code design. 

Criteria:
- Follow the format defined in the `[Template]` section for your requirement documentation. The example provided in the `[Example]` section can be learnt.
- Place the step by step thinking under the `[Thinking]` section.
- The final documentation should be placed under the `[RequirementDoc]` section.

### Approach:
1. First thoroughly understand the feature code design provided in the `[CodeDesignDoc]` section.
2. Reference the content in the [AdditionalContext] section.
3. Develop the feature requirement documentation based on your understanding from step 1 and step 2.

Follow the steps defined in the 'Approach' section. Think and reason meticulously for each section.

[CodeDesignDoc]
$start$
$end$

[FeatureRequirementDoc]


Version 2:
You are a software architect. Using the feature code design documentation provided in the `[CodeDesignDoc]` section, reverse-engineer a feature requirement documentation. 

### Approach:
1. First thoroughly understand the feature code design provided in the `[CodeDesignDoc]` section.
2. Reference the content in the [AdditionalContext] section.
3. Develop the feature requirement documentation based on your understanding from step 1 and step 2.

### Criterias:
- Utilize the format detailed in the `[Template]` section for crafting your requirement documentation. The `[Example]` section serves as a reference.
- Submit the final documentation in the `[RequirementDoc]` section.

### Background:
In the past, our development team did not adhere to the conventional process for feature requirement documentation, but they did produce feature code design documentation. Our goal now is to backtrack to produce the requirement documentation from the existing code design.

Please follow the steps defined in 'Approach'. For each step, think step by step meticulously and reason comprehensively.


[Template]
### <Title>

#### 1. Story/Feature Description:

1.1. **Background**: 
<Provide a detailed background or context regarding the feature or story.>

1.2. **User Persona**: 
<Describe the primary user or users, including their roles and what they need to accomplish.>

1.3. **User Journey**: 
<Detail the user's interaction process with the software or feature, describing their experiences and what they can expect.>

#### 2. Requirements:

2.1. **Functional Requirements**:

- **<Category_1>**:
   - <Requirement_1.1>
   - <Requirement_1.2>
   - ...
   
- **<Category_2>**:
   - <Requirement_2.1>
   - <Requirement_2.2>
   - ...

<Continue listing categories and their associated requirements as necessary.>

[Example]
### File Management System

#### 1. Story/Feature Description:

1.1. **Background**: 
A cloud-based file management system is needed to allow users to store, share, and manage their documents securely and efficiently. This system should ensure data integrity, offer collaboration features, and allow for easy file retrieval and organization.

1.2. **User Persona**: 
End User (Student, Office Worker) who needs to:
  - Save and retrieve documents.
  - Share files with peers.
  - Organize files in folders.
  - Collaborate on documents in real-time.

1.3. **User Journey**: 
A user uploads a document to the cloud storage. They can then share this document with a colleague, allowing for collaborative editing. As they make changes, versions of the document are saved, allowing for easy rollback if necessary. The user can also organize their files in folders, ensuring easy retrieval.

#### 2. Requirements:

2.1. **Functional Requirements**:

- **File Operations**:
   - Upload files to the cloud.
   - Download files from the cloud.
   - Delete files from the cloud.
   - Rename files.
   
- **Collaboration**:
   - Real-time collaborative editing.
   - Commenting on specific parts of a document.
   - Track changes and version history.

- **Organization**:
   - Create folders.
   - Move files between folders.
   - Search for files using keywords.


[CodeDesignDoc]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
The feature orchestrates an automated coding workflow, modularly structured, where each individual step, derived from a `BaseStep`, represents a distinct phase in the workflow. One of the pivotal aspects of the design is that every step employs its own uniquely configured prompt, which is dispatched to a large language model (LLM) for processing. The workflow allows for serialization to JSON, and specific steps can be executed as needed. The design is enhanced with support for multi-layered steps and sub-steps.

1.2. **New Components**:
- **AutomatedCodingWorkflow (New)**: Manages the automated coding workflow. It is in charge of initializing steps, running specific steps, and serializing the workflow to JSON.
- **WORKFLOW_CONFIG (New)**: Offers configuration specifics for the entire workflow.
- **BaseStep (New)**: Serves as a foundational class for workflow steps. Every distinct step derives from this class and has its own prompt configuration for communication with the LLM.
- **WorkflowStatus (New)**: An enumeration potentially representing different states of the workflow.
- **StepsTemplateConfig (New)**: Configuration parameters for individual steps.
- **RequirementStep (New)**: Processes requirements using its own tailored prompt template.
- **ArchitectureDesignStep (New)**: Handles the architectural design phase with its unique prompt.
- **ImplementationStep (New)**: Oversees the coding implementation phase with its distinct prompt.
- **TestGenerationStep (New)**: Dedicated to generating tests for Python code, equipped with a detailed prompt.

1.3. **Existing Components/Dependencies**:
- **LLMIntegrationRegistry (Existing)**: From the `llm_integrations` package, it manages integrations pertinent to LLM.
- **WorkspaceSetting (Existing)**: Originating from the `workspaces` package, it holds workspace-specific settings.
- **PromptTemplate (Existing)**: From the `prompt` package, it's a template structure for constructing prompts.
- **PromptTemplateVariable (Existing)**: Also from the `prompt` package, it defines variables to be embedded in prompt templates.

1.4. **Interactions**: 
- The `AutomatedCodingWorkflow` initializes steps using the `WORKFLOW_CONFIG`.
- Every step, like `RequirementStep` or `ArchitectureDesignStep`, constructs a unique prompt using `PromptTemplate` and `PromptTemplateVariable`.
- The workflow status might be tracked and set using the `WorkflowStatus`.
- Steps may need to interact with the `LLMIntegrationRegistry` for integration management during execution.
- During initialization, the `WorkspaceSetting` is passed to the `AutomatedCodingWorkflow`.

1.5. **External Dependencies**: 
No third-party libraries, services, or tools have been identified from the provided code segments.

#### 2. UML Diagram:

@startuml

package "autobyteus.workflow" {
    abstract class "BaseStep (New)" {
    }

    class "AutomatedCodingWorkflow (New)" {
        + _initialize_steps(steps_config: dict)
        + to_json(): str
        + execute_step(step_id: str): str
        + start_workflow()
    }

    class "WORKFLOW_CONFIG (New)" {
    }

    class "WorkflowStatus (New)" {
    }

    class "StepsTemplateConfig (New)" {
    }

    class "RequirementStep (New)" {
        + construct_prompt(requirement: str): str
        + process_response(response: str): void
        + execute(): void
    }

    class "ArchitectureDesignStep (New)" {
        + construct_prompt(): str
        + process_response(response: str): void
        + execute(): void
    }

    class "ImplementationStep (New)" {
        + construct_prompt(): str
        + process_response(response: str): void
        + execute(): void
    }

    class "TestGenerationStep (New)" {
        + construct_prompt(): str
        + process_response(response: str): void
        + execute(): void
    }

    "RequirementStep (New)" --|> "BaseStep (New)"
    "ArchitectureDesignStep (New)" --|> "BaseStep (New)"
    "ImplementationStep (New)" --|> "BaseStep (New)"
    "TestGenerationStep (New)" --|> "BaseStep (New)"
}

package "autobyteus.llm_integrations" {
    class "LLMIntegrationRegistry (Existing)" {
    }
}

package "autobyteus.workspaces.setting" {
    class "WorkspaceSetting (Existing)" {
    }
}

package "autobyteus.prompt" {
    class "PromptTemplate (Existing)" {
    }

    class "PromptTemplateVariable (Existing)" {
    }
}

"AutomatedCodingWorkflow (New)" --> "BaseStep (New)"
"AutomatedCodingWorkflow (New)" --> "WorkflowStatus (New)"
"AutomatedCodingWorkflow (New)" --> "LLMIntegrationRegistry (Existing)"
"AutomatedCodingWorkflow (New)" --> "WorkspaceSetting (Existing)"
"RequirementStep (New)" --> "PromptTemplate (Existing)"
"RequirementStep (New)" --> "PromptTemplateVariable (Existing)"
"ImplementationStep (New)" --> "PromptTemplate (Existing)"
"TestGenerationStep (New)" --> "PromptTemplate (Existing)"
"TestGenerationStep (New)" --> "PromptTemplateVariable (Existing)"

@enduml

$end$

[AdditionalContext]
This is a feature part of our AI agent application. Each step will interact with large language model. It uses its own prompt, and send request to large language model. It's actually the large language model doing the work, the agent behaves like the hands and feets for the language language model.

[RequirementDoc]
here put the final documentation.

