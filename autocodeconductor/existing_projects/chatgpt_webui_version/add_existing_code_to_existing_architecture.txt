You are a Python software architect. Your task is to improve the existing Feature Code Design Documentation found in the `[Documentation]` section by referencing the Python source code given in the `[SourceCode]` section. The final documentation will follow 
the format defined in the `[Template]` section. The content of each section is enclosed 
between `$start$` and `$end$` tokens.

### Background
In the past, our team wrote codes directly without adhering to the standard practice of initially designing the code architecture. We are now aiming to rectify this by incrementally creating feature code design documentation based on the existing code.

### Approach:
1. Understand the given feature design documentation.
2. Understand the Python code provided in the `[SourceCode]` section. Summarize its primary functions and its association with the existing feature.

3. Analyse each dependency functionality under package `autobyteus` from the given code. Try to analyze whether it's 'part-of' the feature or it's 'used-by' the feature. When the dependencies are under the same package as the package of the source code, then they are 'part-of' dependencies. Otherwise, they are 'used-by' dependencies.
4. Based on previous analysis steps, start to enhance the given design documentation by adding 'part-of' dependencies as new components and 'used-by' dependencies as existing components Ensure the revised documentation aligns with the format described in the `[Template]` section.

Follow the steps defined in the 'Approach'. Think step by step meticously and reason comprehensively for each step to address the task.


[Template]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
- Provide a brief overview of the primary architecture.
- Are there any design patterns that will be applied?

1.2. **New Components**:
- **ComponentA (New)**: Describe its purpose, role, and functionality.
- **ComponentB (New)**: Describe its purpose, role, and functionality.
... Continue as needed.
  
1.3. **Existing Components/Dependencies**:
- **ComponentX (Existing)**: Briefly describe its role and from which feature/module it originates.
- **ComponentY (Existing)**: Briefly describe its role and from which feature/module it originates.
... Continue as needed.

1.4. **Interactions**: 
- How do the new components interact with each other?
- How do the new components interact with the existing components?

1.5. **External Dependencies**: 
- List any third-party libraries, services, or tools that will be used.
- Are there any specific versions or configurations to be aware of?

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

@startuml
... UML content here ...
@enduml

[Documentation]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
This feature is designed to manage a fully automated coding workflow. It is modular, with each step in the workflow being a separate component. The workflow can be serialized to JSON, and specific steps can be executed. Furthermore, steps can be multi-layered with sub-steps.

1.2. **New Components**:
- **AutomatedCodingWorkflow (New)**: This is the main component that manages the automated coding workflow. It is responsible for initializing steps, executing steps, and serializing the workflow to JSON.
- **WORKFLOW_CONFIG (New)**: Provides configuration details for the workflow.
- **BaseStep (New)**: Represents a base class for steps in the workflow. Steps in the workflow derive from this class.
- **WorkflowStatus (New)**: Likely an enumeration that represents the status of a workflow.
- **StepsTemplateConfig (New)**: Configuration details for the steps in the workflow.

1.3. **Existing Components/Dependencies**:
- **LLMIntegrationRegistry (Existing)**: From the `llm_integrations` package. Manages integrations related to LLM.
- **WorkspaceSetting (Existing)**: From the `workspaces` package. Represents settings related to a workspace.

1.4. **Interactions**: 
- The `AutomatedCodingWorkflow` uses the `WORKFLOW_CONFIG` to initialize steps.
- The `BaseStep` class is used by the `AutomatedCodingWorkflow` to represent steps.
- The `WorkflowStatus` enumeration might be used to set and track the status of the workflow.
- The `LLMIntegrationRegistry` might be used to manage integrations when executing steps.
- The `WorkspaceSetting` is passed to the `AutomatedCodingWorkflow` during initialization.

1.5. **External Dependencies**: 
None observed from the provided code segment.

#### 2. UML Diagram:

@startuml

package "autobyteus.workflow" {
    class "AutomatedCodingWorkflow (New)" {
        + _initialize_steps(steps_config: dict)
        + to_json(): str
        + execute_step(step_id: str): str
        + start_workflow()
    }

    class "WORKFLOW_CONFIG (New)" {
    }

    class "BaseStep (New)" {
    }

    class "WorkflowStatus (New)" {
    }

    class "StepsTemplateConfig (New)" {
    }
}

package "autobyteus.llm_integrations" {
    class "LLMIntegrationRegistry (Existing)" {
    }
}

package "autobyteus.workspaces.setting" {
    class "WorkspaceSetting (Existing)" {
    }
}

"AutomatedCodingWorkflow (New)" --> "WORKFLOW_CONFIG (New)"
"AutomatedCodingWorkflow (New)" --> "BaseStep (New)"
"AutomatedCodingWorkflow (New)" --> "WorkflowStatus (New)"
"AutomatedCodingWorkflow (New)" --> "LLMIntegrationRegistry (Existing)"
"AutomatedCodingWorkflow (New)" --> "WorkspaceSetting (Existing)"

@enduml

[SourceCode]
```
# src/workflow/steps/requirement_step.py

"""
requirement_step.py

This module contains the RequirementStep class, derived from the Step base class.
"""

from abc import abstractmethod
from typing_extensions import override
from autobyteus.prompt.prompt_template import PromptTemplate
from autobyteus.prompt.prompt_template_variable import PromptTemplateVariable
from autobyteus.workflow.types.base_step import BaseStep

class RequirementStep(BaseStep):
    name = "requirement"
    
    # Define the PromptTemplateVariable
    requirement_variable = PromptTemplateVariable(name="requirement", 
                                                  source=PromptTemplateVariable.SOURCE_USER_INPUT, 
                                                  allow_code_context_building=True, 
                                                  allow_llm_refinement=True)

    # Define the PromptTemplate
    prompt_template = PromptTemplate(
        template="""
        As the best Python software engineer on earth, address the requriements outlined between the `$start$` and `$end$` tokens in the `[Requirement]` section.
        [Guidelines]
        - Use appropriate design patterns where neccessary.
        - Follow SOLID principles and Python's best coding practices.
        - Consider refactoring where necessary.
        - Follow python docstring best practices, ensuring each file begins with a file-level docstring.
        - Include file paths with their complete codes in code block in the output, so i can easily copy and paste. Do not use placeholders.
        - Explain whether to create a new folder or use an existing one for file placement. Use descriptive naming conventions for files and folders that correlate with the requirement's features. For context, 
            the current project's file structure looks like this:
            - src
                - ...
                - semantic_code
                    - embedding
                        - openai_embedding_creator.py
            - tests
                - unit_tests
                    - ...
                    - semantic_code
                        - embedding
                            - test_openai_embedding_creator.py
                - integration_tests
                    - ...
                    - semantic_code
                        - index
                            - test_index_service_integration.py
                    
    - Always use absolute imports over relative ones.
    - Update docstrings in line with any code modifications.

    Think step by step, and reason comphrehensively to address the task.
    [Requirement]
    $start$
    {requirement}
    $end$
    """,
        variables=[requirement_variable]
    )
    
    @override
    def construct_prompt(self, requirement: str) -> str:
        """
        Construct the prompt for the requirement step.

        Args:
            requirement (str): The requirement to be filled in the prompt_template.

        Returns:
            str: The constructed prompt for the requirement step.
        """
        # Use the PromptTemplate's method to fill in the variable
        prompt = self.prompt_template.fill({"requirement": requirement})
        return prompt
    
    def process_response(self, response: str) -> None:
        """
        Process the response from the LLM API for this step.

        Args:
            response (str): The LLM API response as a string.
        """
        raise NotImplementedError("Derived classes must implement the execute method.")


    def execute(self) -> None:
        """
        Execute the step.

        This method should be implemented in derived classes to define the step's execution logic.
        """
        raise NotImplementedError("Derived classes must implement the execute method.")

```













