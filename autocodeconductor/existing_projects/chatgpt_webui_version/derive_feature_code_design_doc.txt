You are a Python software architect. Based on the Python source code provided in the `[SourceCode]` and the context provided in the `[Context]` sections, your task is to create feature architecture design documentation and a plantuml diagram that represents the architecture and design.

Criteria:
- The final documentation should follow the format defined in the `[Template]` section.
- Ensure your UML diagram in the documentation adheres to the plantuml syntax. The UML will also contains some explanation notes, taking inspiration from the example provided in the `[Example]` section.
- The final documentation should be placed in a copiable code block.

Think step by step meticously before output the final documentation. 

[Template]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
- Provide a brief overview of the primary architecture.
- Are there any design patterns that will be applied?

1.2. **New Components**:
- **ComponentA (New)**: Describe its purpose, role, and functionality.
- **ComponentB (New)**: Describe its purpose, role, and functionality.
... Continue as needed.
  
1.3. **Existing Components/Dependencies**:
- **ComponentX (Existing)**: Briefly describe its role and from which feature/module it originates.
- **ComponentY (Existing)**: Briefly describe its role and from which feature/module it originates.
... Continue as needed.

1.4. **Interactions**: 
- How do the new components interact with each other?
- How do the new components interact with the existing components?

1.5. **External Dependencies**: 
- List any third-party libraries, services, or tools that will be used.
- Are there any specific versions or configurations to be aware of?

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

@startuml
... UML content here ...
@enduml


[Example]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
This feature implements the Observer Pattern, allowing numerous subscribers to be notified of certain events. An existing EventDatabase will store all the triggered events.

1.2. **New Components**:
- **Publisher (New)**: Broadcasts events to all subscribers and logs them to the EventDatabase.
- **Subscriber (New)**: Monitors and responds to particular events.

1.3. **Existing Components/Dependencies**:
- **EventDatabase (Existing)**: A database component that stores all triggered events.

1.4. **Interactions**: 
- Users liaise with the Publisher to initiate events. 
- The Publisher logs the event to the EventDatabase.
- Subsequently, the Publisher notifies all Subscribers of this occurrence.

1.5. **External Dependencies**: 
None.

#### 2. UML Diagram:

@startuml

class "Publisher (New)" {
    + trigger_event()
    + add_subscriber(subscriber: Subscriber)
    + log_event_to_database(event: Event)
}

class "Subscriber (New)" {
    + on_event_received()
}

class "EventDatabase (Existing)" {
    + save_event(event: Event)
}

"Publisher (New)" --> "Subscriber (New)": Event notification
"Publisher (New)" --> "EventDatabase (Existing)": Logs event

note bottom of "Publisher (New)"
    The Publisher is central to the Observer pattern.
    It broadcasts events and handles the addition of new subscribers.
end note

note right of "EventDatabase (Existing)"
    This is an existing database component.
    New events are logged here by the Publisher.
end note

@enduml

[SourceCode]
$start$
# src/automated_coding_workflow/automated_coding_workflow.py
"""
automated_coding_workflow.py: Contains the AutomatedCodingStep class, which represents the main entry point for running the automated coding workflow.
"""

import json
from typing import Dict, Optional
from autobyteus.workflow.config import WORKFLOW_CONFIG
from autobyteus.llm_integrations.llm_integration_registry import LLMIntegrationRegistry
from autobyteus.workflow_types.types.base_step import BaseStep
from autobyteus.workflow_types.types.workflow_status import WorkflowStatus
from autobyteus.workflow_types.types.workflow_template_config import StepsTemplateConfig
from autobyteus.workspaces.setting.workspace_setting import WorkspaceSetting  # Import WorkspaceSetting


class AutomatedCodingWorkflow:
    """
    A class to represent and manage a fully automated coding workflow.

    The workflow is composed of multiple steps, each step represented as an instance of a class derived from BaseStep. Steps can have sub-steps, forming a potentially multi-level workflow.

    Attributes:
        workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        steps (Dict[str, BaseStep]): A dictionary of step instances keyed by their step IDs.
        name (str): The name of the workflow. Default is "automated_coding_workflow".
        config (dict): The configuration details for the workflow. Loaded from `WORKFLOW_CONFIG`.
    """

    name = "automated_coding_workflow"
    config = WORKFLOW_CONFIG

    def __init__(self, workspace_setting: WorkspaceSetting): 
        """
        Initialize the AutomatedCodingWorkflow with the given workspace setting.

        Args:
            workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        """
        self.workspace_setting = workspace_setting
        self.llm_integration_registry = LLMIntegrationRegistry()
        self.steps: Dict[str, BaseStep] = {}
        self._initialize_steps(AutomatedCodingWorkflow.config['steps'])
    
    def _initialize_steps(self, steps_config: Dict[str, StepsTemplateConfig]):
        """
        Initializes the steps of the workflow from a given configuration.

        If a step has sub-steps, it recursively initializes those as well.

        :param steps_config: A dictionary containing step configuration.
        """
        for step_id, step_config in steps_config.items():
            step_class = step_config['step_class']
            step_instance: BaseStep = step_class(self)
            self.steps[step_id] = step_instance

            if 'steps' in step_config:
                self._initialize_steps(step_config['steps'])

    def to_json(self) -> str:
        """
        Converts the workflow instance to a JSON representation, including its steps.

        Returns:
            str: The JSON representation of the workflow instance.
        """
        workflow_data = {
            "name": self.name,
            "steps": {step_id: step.to_dict() for step_id, step in self.steps.items()}
        }

        return json.dumps(workflow_data)
    
    def execute_step(self, step_id: str) -> Optional[str]:
        """
        Execute a specific step within the workflow using its ID.

        :param step_id: The ID of the step to execute.
        :return: The step result or None if the step_id is invalid.
        :raises ValueError: If the provided step_id is invalid.
        """
        step = self.steps.get(step_id)
        if step:
            return step.execute()
        else:
            raise ValueError(f"Invalid step_id: {step_id}")


    def start_workflow(self):
        """
        Set the status of the workflow to Started and raise a NotImplementedError for derived classes to implement.
        """
        self.status = WorkflowStatus.Started

$end$


As a Python software architect, you are tasked with creating design documentation for a feature based on provided Python source code. Your objective is to analyze the code, discern its role in the feature's architecture, and generate a part of the feature's design documentation.

**Criteria**:
- Analyze the source code provided in the `[SourceCode]` section.
- Determine the primary focus and context of the feature from the class/module, considering naming conventions and imported packages/classes.
- For the context of this task, classes/modules directly related to the primary focus of the feature (e.g., automated coding workflow) should be treated as new.
- Only components that seem external or unrelated to the core feature should be considered existing.
- Create documentation that aligns with the format in the `[Template]` section.
- Design a PlantUML diagram representing the architecture, ensuring it follows the PlantUML syntax. Use notes inspired by the example in `[Example]`.

**Background**:
The development process for this new feature requires comprehensive design documentation before actual development. The provided code represents what the final implementation might look like. Your job is to visualize and document the architecture of this feature based on the provided code.

**Steps**:
1. **Analyze the Code**: Understand its purpose, functionality, and potential relationships. Pay close attention to naming conventions and imports.
2. **Feature Context**: Determine the primary focus of the feature. Identify any hints from imported classes/packages that might be part of the feature.
3. **Document**: Draft the design documentation according to the `[Template]` format.
4. **UML Diagram**: Construct a PlantUML diagram that offers a visual representation of the class/module within the feature's architecture.
5. **Review**: Ensure the documentation and UML diagram capture the broader context and meet the provided criteria.


Your meticulous approach is key to capturing the essence of the feature and its architecture comprehensively.

[Template]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
- Provide a brief overview of the primary architecture.
- Are there any design patterns that will be applied?

1.2. **New Components**:
- **ComponentA (New)**: Describe its purpose, role, and functionality.
- **ComponentB (New)**: Describe its purpose, role, and functionality.
... Continue as needed.
  
1.3. **Existing Components/Dependencies**:
- **ComponentX (Existing)**: Briefly describe its role and from which feature/module it originates.
- **ComponentY (Existing)**: Briefly describe its role and from which feature/module it originates.
... Continue as needed.

1.4. **Interactions**: 
- How do the new components interact with each other?
- How do the new components interact with the existing components?

1.5. **External Dependencies**: 
- List any third-party libraries, services, or tools that will be used.
- Are there any specific versions or configurations to be aware of?

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

@startuml
... UML content here ...
@enduml


[Example]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
This feature implements the Observer Pattern, allowing numerous subscribers to be notified of certain events. An existing EventDatabase will store all the triggered events.

1.2. **New Components**:
- **Publisher (New)**: Broadcasts events to all subscribers and logs them to the EventDatabase.
- **Subscriber (New)**: Monitors and responds to particular events.

1.3. **Existing Components/Dependencies**:
- **EventDatabase (Existing)**: A database component that stores all triggered events.

1.4. **Interactions**: 
- Users liaise with the Publisher to initiate events. 
- The Publisher logs the event to the EventDatabase.
- Subsequently, the Publisher notifies all Subscribers of this occurrence.

1.5. **External Dependencies**: 
None.

#### 2. UML Diagram:

@startuml

class "Publisher (New)" {
    + trigger_event()
    + add_subscriber(subscriber: Subscriber)
    + log_event_to_database(event: Event)
}

class "Subscriber (New)" {
    + on_event_received()
}

class "EventDatabase (Existing)" {
    + save_event(event: Event)
}

"Publisher (New)" --> "Subscriber (New)": Event notification
"Publisher (New)" --> "EventDatabase (Existing)": Logs event

note bottom of "Publisher (New)"
    The Publisher is central to the Observer pattern.
    It broadcasts events and handles the addition of new subscribers.
end note

note right of "EventDatabase (Existing)"
    This is an existing database component.
    New events are logged here by the Publisher.
end note

@enduml

[SourceCode]
$start$
# src/automated_coding_workflow/automated_coding_workflow.py
"""
automated_coding_workflow.py: Contains the AutomatedCodingStep class, which represents the main entry point for running the automated coding workflow.
"""

import json
from typing import Dict, Optional
from autobyteus.workflow.config import WORKFLOW_CONFIG
from autobyteus.llm_integrations.llm_integration_registry import LLMIntegrationRegistry
from autobyteus.workflow_types.types.base_step import BaseStep
from autobyteus.workflow_types.types.workflow_status import WorkflowStatus
from autobyteus.workflow_types.types.workflow_template_config import StepsTemplateConfig
from autobyteus.workspaces.setting.workspace_setting import WorkspaceSetting  # Import WorkspaceSetting


class AutomatedCodingWorkflow:
    """
    A class to represent and manage a fully automated coding workflow.

    The workflow is composed of multiple steps, each step represented as an instance of a class derived from BaseStep. Steps can have sub-steps, forming a potentially multi-level workflow.

    Attributes:
        workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        steps (Dict[str, BaseStep]): A dictionary of step instances keyed by their step IDs.
        name (str): The name of the workflow. Default is "automated_coding_workflow".
        config (dict): The configuration details for the workflow. Loaded from `WORKFLOW_CONFIG`.
    """

    name = "automated_coding_workflow"
    config = WORKFLOW_CONFIG

    def __init__(self, workspace_setting: WorkspaceSetting): 
        """
        Initialize the AutomatedCodingWorkflow with the given workspace setting.

        Args:
            workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        """
        self.workspace_setting = workspace_setting
        self.llm_integration_registry = LLMIntegrationRegistry()
        self.steps: Dict[str, BaseStep] = {}
        self._initialize_steps(AutomatedCodingWorkflow.config['steps'])
    
    def _initialize_steps(self, steps_config: Dict[str, StepsTemplateConfig]):
        """
        Initializes the steps of the workflow from a given configuration.

        If a step has sub-steps, it recursively initializes those as well.

        :param steps_config: A dictionary containing step configuration.
        """
        for step_id, step_config in steps_config.items():
            step_class = step_config['step_class']
            step_instance: BaseStep = step_class(self)
            self.steps[step_id] = step_instance

            if 'steps' in step_config:
                self._initialize_steps(step_config['steps'])

    def to_json(self) -> str:
        """
        Converts the workflow instance to a JSON representation, including its steps.

        Returns:
            str: The JSON representation of the workflow instance.
        """
        workflow_data = {
            "name": self.name,
            "steps": {step_id: step.to_dict() for step_id, step in self.steps.items()}
        }

        return json.dumps(workflow_data)
    
    def execute_step(self, step_id: str) -> Optional[str]:
        """
        Execute a specific step within the workflow using its ID.

        :param step_id: The ID of the step to execute.
        :return: The step result or None if the step_id is invalid.
        :raises ValueError: If the provided step_id is invalid.
        """
        step = self.steps.get(step_id)
        if step:
            return step.execute()
        else:
            raise ValueError(f"Invalid step_id: {step_id}")


    def start_workflow(self):
        """
        Set the status of the workflow to Started and raise a NotImplementedError for derived classes to implement.
        """
        self.status = WorkflowStatus.Started

$end$




You are a Python software architect. Your task is to analyze Python source code to discern the architecture and design of a software feature. Based on your analysis, craft a feature architecture design documentation complemented with a PlantUML diagram.

### Criteria:
- Analyze the Python source code provided in `[SourceCode]`.
- The final design documentation should adhere to the format in the `[Template]` section.
- Ensure the UML diagram within the documentation follows PlantUML syntax and includes explanatory notes, as shown in `[Example]`.
- Present the completed documentation in a copiable code block.


### Approach:
1. Analyze the Code: Comprehend the code's primary purpose. Identify key classes, methods, and their interrelations.
2. Determine Feature Boundaries: Decide on the central classes and components of the feature. Recognize if imported classes are part of the feature. 
3. Craft the Documentation: Use the `[Template]` to document the architecture.
4. Design the UML Diagram: Visualize the architecture using PlantUML, ensuring clarity and conciseness.
5. Finalize & Re-evaluate: Review the documentation and diagram. Revisit your observations if needed, ensuring alignment with the feature's core.

Think meticulously and step-by-step to produce a comprehensive and insightful documentation.

[Template]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
- Provide a brief overview of the primary architecture.
- Are there any design patterns that will be applied?

1.2. **New Components**:
- **ComponentA (New)**: Describe its purpose, role, and functionality.
- **ComponentB (New)**: Describe its purpose, role, and functionality.
... Continue as needed.
  
1.3. **Existing Components/Dependencies**:
- **ComponentX (Existing)**: Briefly describe its role and from which feature/module it originates.
- **ComponentY (Existing)**: Briefly describe its role and from which feature/module it originates.
... Continue as needed.

1.4. **Interactions**: 
- How do the new components interact with each other?
- How do the new components interact with the existing components?

1.5. **External Dependencies**: 
- List any third-party libraries, services, or tools that will be used.
- Are there any specific versions or configurations to be aware of?

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

@startuml
... UML content here ...
@enduml


[Example]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
This feature implements the Observer Pattern, allowing numerous subscribers to be notified of certain events. An existing EventDatabase will store all the triggered events.

1.2. **New Components**:
- **Publisher (New)**: Broadcasts events to all subscribers and logs them to the EventDatabase.
- **Subscriber (New)**: Monitors and responds to particular events.

1.3. **Existing Components/Dependencies**:
- **EventDatabase (Existing)**: A database component that stores all triggered events.

1.4. **Interactions**: 
- Users liaise with the Publisher to initiate events. 
- The Publisher logs the event to the EventDatabase.
- Subsequently, the Publisher notifies all Subscribers of this occurrence.

1.5. **External Dependencies**: 
None.

#### 2. UML Diagram:

@startuml

class "Publisher (New)" {
    + trigger_event()
    + add_subscriber(subscriber: Subscriber)
    + log_event_to_database(event: Event)
}

class "Subscriber (New)" {
    + on_event_received()
}

class "EventDatabase (Existing)" {
    + save_event(event: Event)
}

"Publisher (New)" --> "Subscriber (New)": Event notification
"Publisher (New)" --> "EventDatabase (Existing)": Logs event

note bottom of "Publisher (New)"
    The Publisher is central to the Observer pattern.
    It broadcasts events and handles the addition of new subscribers.
end note

note right of "EventDatabase (Existing)"
    This is an existing database component.
    New events are logged here by the Publisher.
end note

@enduml

[SourceCode]
$start$
# src/automated_coding_workflow/automated_coding_workflow.py
"""
automated_coding_workflow.py: Contains the AutomatedCodingStep class, which represents the main entry point for running the automated coding workflow.
"""

import json
from typing import Dict, Optional
from autobyteus.workflow.config import WORKFLOW_CONFIG
from autobyteus.llm_integrations.llm_integration_registry import LLMIntegrationRegistry
from autobyteus.workflow_types.types.base_step import BaseStep
from autobyteus.workflow_types.types.workflow_status import WorkflowStatus
from autobyteus.workflow_types.types.workflow_template_config import StepsTemplateConfig
from autobyteus.workspaces.setting.workspace_setting import WorkspaceSetting  # Import WorkspaceSetting


class AutomatedCodingWorkflow:
    """
    A class to represent and manage a fully automated coding workflow.

    The workflow is composed of multiple steps, each step represented as an instance of a class derived from BaseStep. Steps can have sub-steps, forming a potentially multi-level workflow.

    Attributes:
        workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        steps (Dict[str, BaseStep]): A dictionary of step instances keyed by their step IDs.
        name (str): The name of the workflow. Default is "automated_coding_workflow".
        config (dict): The configuration details for the workflow. Loaded from `WORKFLOW_CONFIG`.
    """

    name = "automated_coding_workflow"
    config = WORKFLOW_CONFIG

    def __init__(self, workspace_setting: WorkspaceSetting): 
        """
        Initialize the AutomatedCodingWorkflow with the given workspace setting.

        Args:
            workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        """
        self.workspace_setting = workspace_setting
        self.llm_integration_registry = LLMIntegrationRegistry()
        self.steps: Dict[str, BaseStep] = {}
        self._initialize_steps(AutomatedCodingWorkflow.config['steps'])
    
    def _initialize_steps(self, steps_config: Dict[str, StepsTemplateConfig]):
        """
        Initializes the steps of the workflow from a given configuration.

        If a step has sub-steps, it recursively initializes those as well.

        :param steps_config: A dictionary containing step configuration.
        """
        for step_id, step_config in steps_config.items():
            step_class = step_config['step_class']
            step_instance: BaseStep = step_class(self)
            self.steps[step_id] = step_instance

            if 'steps' in step_config:
                self._initialize_steps(step_config['steps'])

    def to_json(self) -> str:
        """
        Converts the workflow instance to a JSON representation, including its steps.

        Returns:
            str: The JSON representation of the workflow instance.
        """
        workflow_data = {
            "name": self.name,
            "steps": {step_id: step.to_dict() for step_id, step in self.steps.items()}
        }

        return json.dumps(workflow_data)
    
    def execute_step(self, step_id: str) -> Optional[str]:
        """
        Execute a specific step within the workflow using its ID.

        :param step_id: The ID of the step to execute.
        :return: The step result or None if the step_id is invalid.
        :raises ValueError: If the provided step_id is invalid.
        """
        step = self.steps.get(step_id)
        if step:
            return step.execute()
        else:
            raise ValueError(f"Invalid step_id: {step_id}")


    def start_workflow(self):
        """
        Set the status of the workflow to Started and raise a NotImplementedError for derived classes to implement.
        """
        self.status = WorkflowStatus.Started

$end$



As a Python software architect, you are tasked with retroactively creating design documentation for a feature based on given source code. 

### Background:
- The source code is a segment of a larger feature; not all relevant modules for the feature are present in the source code section.
- The goal is to create retroactive documentation based on existing code incrementally.
- Identify the feature's core components and differentiate from external dependencies.

### Criteria:
- The final design documentation should adhere to the format in the `[Template]` section.
- Ensure the UML diagram within the documentation follows PlantUML syntax and includes explanatory notes, as shown in `[Example]`.
- Present the completed documentation in a copiable code block.

### Approach
- Understand the source code, and determine the primary focus and context of the feature.
- For the context of the feature, classes/modules directly related to the primary focus of the feature (e.g., automated coding workflow) should be treated as new. Only components that seem external or unrelated to the core feature should be considered existing. Normally class name or package name can give big hints whether the dependent classes or module belong to the same feature to not. 


Think step by step meticously and reason comprehensively to address the task.




As a Python-focused software architect, you're tasked with crafting design documentation for a specific feature using its source code.

**Background:**
The provided source code is a portion of a larger feature. Not all modules related to this feature are available. Your objective is to incrementally draft retroactive documentation based on this existing code, identifying its main components while distinguishing them from external dependencies.

**Criteria:**
- Adhere to the format outlined in the `[Template]` section.
- Ensure your UML diagram aligns with the PlantUML syntax. It should also be accompanied by explanatory notes, akin to the `[Example]` section.
- Provide your final documentation in a format that can be easily copied.

**Approach:**
1. Thoroughly analyze the source code to grasp the feature's main objective and context.
2. Identify classes or modules that are directly related to the feature's main objective. Treat these as new components. Use class or package names as indicators.
3. Consider components that seem unrelated to the feature's core as existing external dependencies.

Ensure you approach this task methodically and reason through each step.




You are a Python software architect tasked with retroactively creating design documentation for a specific feature using its provided source code segment.

### Background:
- Previously, the design documentation was overlooked, and the coding was done directly. Now, the aim is to reverse-engineer the documentation from the existing code, piece by piece.
- The source code provided represents only a portion of the full feature and might exclude some essential modules.
- The objective is to progressively draft documentation from this code, detailing the feature's primary components and distinguishing them from external dependencies.

### Criteria:
- Follow the format specified in the `[Template]` section.
- Incorporate a UML diagram consistent with PlantUML syntax, complemented by explanatory notes as demonstrated in `[Example]`.
- Offer your finalized design documentation in a copiable code block.

### Steps:
1. Analyse the source code to ascertain what feature it is related to the code.
2. Think and reason meticously the possible functionality of each dependent class or module. 
3. Think and reason meticulously about the functionality of each dependent class or module. Determine if the functionality is intrinsically tied to the purpose of the feature. If yes, label it as 'new'. If the functionality seems to be more of a utility or an external helper not specific to the feature's core functionality, label it as 'existing'. 
Output of this section as: "The functionality of this module based on the previous analysis is, which is closely related to the feature, so this module could belong to this feature, hense mark it as "new". 


4. After the comprehensive analysis, begin drafting the documentation.

Follow the `Steps` and think meticulously and reason comprehensively throughout in each step.

3. Analyse each dependency functionality under package `autobyteus`. If it's functionality is related to the feature, label it as 'current-feature', otherwise label it as 'other-feature'. 
Use the following output structure: "The feature is about baba, this module performs XYZ, which is likely part of the feature. Therefore, i think it's part of the feature, even though the source code is not given. I label it as 'current-feature'. This module performs ZZZ, which seems only providing functionality to the feature. Hence, we label it as 'other-feature'". Later, "current-feature" labeled dependencies become "new" components. "other-feature" becomes "existing" components.



You are a Python software architect. Your responsibility is to reverse-engineer the given code back to feature code design.

### Background
- In software engineering, standard process follows feature requirement, feature code design, subtask creation, subtask implementation sequence. However, due to management issues, the standard process was not followed. The code was implemented without feature code design documentation. Now we need to retroactively
create the feature code design documentation based on given code incrementally.

### Criteria:
- Final documentation should follow the format specified in the `[Template]` section.
- Final documentation should include a UML diagram following PlantUML syntax, complemented by explanatory notes as demonstrated in `[Example]`.
- Present your finalized design documentation in a copiable code block.

### Steps:
1. Understand the source code given in the [SourceCode] section. 
2. Summarize what feature this code segment could be trying implement.
3. Analyse each dependency functionality under package `autobyteus`. Try to analyze whether it's 'part-of' the feature or it's 'used-by' the feature. When the dependencies are under the same package as the package in the source code, then they are 'part-of' dependencies. Otherwise, they are 'used-by' dependencies.
4. After your detailed analysis, start compiling the design documentation. All the dependencies labeled with 'part-of' become new components. Dependencies labled with 'used-by' become existing components.

Please follow the `Steps` defined, ensure a meticulous approach and comprehensive reasoning for each step.


You are a Python software architect tasked with reverse-engineering a given piece of code to craft its design documentation.

### Background
In typical software development, the process starts with defining feature requirements, followed by designing code for the feature, creating subtasks, and then implementing those subtasks. Due to some managerial hiccups, the initial design documentation was overlooked. Your role is to retroactively draft this missing design documentation based on the provided code.

### Guidelines:
- Adhere to the format given in the `[Template]` section.
- Your documentation should incorporate a UML diagram following the PlantUML syntax and be supplemented with explanatory notes, as illustrated in `[Example]`.
- Provide your final design documentation within a copiable code block.

### Procedure:
1. Examine the source code in the [SourceCode] section.
2. Deduce the probable feature this code segment aims to implement.
3. Scrutinize each project package dependency (excluding standard third-party packages). Determine if it's a 'part-of' or 'used-by' the feature. Dependencies within the same package as the source code are considered 'part-of' the feature, while others are 'used-by' dependencies.
4. Based on your analysis, begin drafting the design documentation. Treat 'part-of' dependencies as new components and 'used-by' dependencies as existing ones.

Ensure you adhere to the outlined procedure, ensure a meticulous approach and comprehensive reasoning for each step.




[Template]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
- Provide a brief overview of the primary architecture.
- Are there any design patterns that will be applied?

1.2. **New Components**:
- **ComponentA (New)**: Describe its purpose, role, and functionality.
- **ComponentB (New)**: Describe its purpose, role, and functionality.
... Continue as needed.
  
1.3. **Existing Components/Dependencies**:
- **ComponentX (Existing)**: Briefly describe its role and from which feature/module it originates.
- **ComponentY (Existing)**: Briefly describe its role and from which feature/module it originates.
... Continue as needed.

1.4. **Interactions**: 
- How do the new components interact with each other?
- How do the new components interact with the existing components?

1.5. **External Dependencies**: 
- List any third-party libraries, services, or tools that will be used.
- Are there any specific versions or configurations to be aware of?

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

#### 2. UML Diagram:
- Attach the UML diagram.
- **UML Legend**:
  - Components marked with `(New)` are to be developed as part of this feature.
  - Components marked with `(Existing)` are pre-existing and should be treated as dependencies.

@startuml
... UML content here ...
@enduml


[Example]
### Feature Code Design Documentation:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
This feature implements the Observer Pattern, allowing numerous subscribers to be notified of certain events. An existing EventDatabase will store all the triggered events.

1.2. **New Components**:
- **Publisher (New)**: Broadcasts events to all subscribers and logs them to the EventDatabase.
- **Subscriber (New)**: Monitors and responds to particular events.

1.3. **Existing Components/Dependencies**:
- **EventDatabase (Existing)**: A database component that stores all triggered events.

1.4. **Interactions**: 
- Users liaise with the Publisher to initiate events. 
- The Publisher logs the event to the EventDatabase.
- Subsequently, the Publisher notifies all Subscribers of this occurrence.

1.5. **External Dependencies**: 
None.

#### 2. UML Diagram:

@startuml

class "Publisher (New)" {
    + trigger_event()
    + add_subscriber(subscriber: Subscriber)
    + log_event_to_database(event: Event)
}

class "Subscriber (New)" {
    + on_event_received()
}

class "EventDatabase (Existing)" {
    + save_event(event: Event)
}

"Publisher (New)" --> "Subscriber (New)": Event notification
"Publisher (New)" --> "EventDatabase (Existing)": Logs event

note bottom of "Publisher (New)"
    The Publisher is central to the Observer pattern.
    It broadcasts events and handles the addition of new subscribers.
end note

note right of "EventDatabase (Existing)"
    This is an existing database component.
    New events are logged here by the Publisher.
end note

@enduml

[SourceCode]
$start$
# autobyteus/workflow/automated_coding_workflow.py
"""
automated_coding_workflow.py: Contains the AutomatedCodingStep class, which represents the main entry point for running the automated coding workflow.
"""

import json
from typing import Dict, Optional
from autobyteus.workflow.config import WORKFLOW_CONFIG
from autobyteus.llm_integrations.llm_integration_registry import LLMIntegrationRegistry
from autobyteus.workflow.types.base_step import BaseStep
from autobyteus.workflow.types.base_workflow import WorkflowStatus
from autobyteus.workflow.types.workflow_template_config import StepsTemplateConfig
from autobyteus.workspaces.setting.workspace_setting import WorkspaceSetting  # Import WorkspaceSetting


class AutomatedCodingWorkflow:
    """
    A class to represent and manage a fully automated coding workflow.

    The workflow is composed of multiple steps, each step represented as an instance of a class derived from BaseStep. Steps can have sub-steps, forming a potentially multi-level workflow.

    Attributes:
        workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        steps (Dict[str, BaseStep]): A dictionary of step instances keyed by their step IDs.
        name (str): The name of the workflow. Default is "automated_coding_workflow".
        config (dict): The configuration details for the workflow. Loaded from `WORKFLOW_CONFIG`.
    """

    name = "automated_coding_workflow"
    config = WORKFLOW_CONFIG

    def __init__(self, workspace_setting: WorkspaceSetting): 
        """
        Initialize the AutomatedCodingWorkflow with the given workspace setting.

        Args:
            workspace_setting (WorkspaceSetting): The settings associated with the workspace.
        """
        self.workspace_setting = workspace_setting
        self.llm_integration_registry = LLMIntegrationRegistry()
        self.steps: Dict[str, BaseStep] = {}
        self._initialize_steps(AutomatedCodingWorkflow.config['steps'])
    
    def _initialize_steps(self, steps_config: Dict[str, StepsTemplateConfig]):
        """
        Initializes the steps of the workflow from a given configuration.

        If a step has sub-steps, it recursively initializes those as well.

        :param steps_config: A dictionary containing step configuration.
        """
        for step_id, step_config in steps_config.items():
            step_class = step_config['step_class']
            step_instance: BaseStep = step_class(self)
            self.steps[step_id] = step_instance

            if 'steps' in step_config:
                self._initialize_steps(step_config['steps'])

    def to_json(self) -> str:
        """
        Converts the workflow instance to a JSON representation, including its steps.

        Returns:
            str: The JSON representation of the workflow instance.
        """
        workflow_data = {
            "name": self.name,
            "steps": {step_id: step.to_dict() for step_id, step in self.steps.items()}
        }

        return json.dumps(workflow_data)
    
    def execute_step(self, step_id: str) -> Optional[str]:
        """
        Execute a specific step within the workflow using its ID.

        :param step_id: The ID of the step to execute.
        :return: The step result or None if the step_id is invalid.
        :raises ValueError: If the provided step_id is invalid.
        """
        step = self.steps.get(step_id)
        if step:
            return step.execute()
        else:
            raise ValueError(f"Invalid step_id: {step_id}")


    def start_workflow(self):
        """
        Set the status of the workflow to Started and raise a NotImplementedError for derived classes to implement.
        """
        self.status = WorkflowStatus.Started

$end$
