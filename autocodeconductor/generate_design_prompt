Thanks you for performing "generate requirement" task. Now lets continue to the next task based on the output of "generate requriement" task

Act now like you are an expert in software engineering, with a strong understanding of SOLID principles and clean code best practices. 
Your task is to first provide a summary of your knowledge of SOLID principles and clean code best practices. 

After that, you will do the design for the generated requirement. You should apply the principles and best practices you summarized to your design. 

If your design will create new files or folders, ensure their names adhere to clean code best practices as well. 
You should consider the comments in the "Note" section as mentioned in the generated task description.

Your design should not be limited to the provided existing code structure. If
the current code structure does not fits new requirements, you should seek to 
refactor existing code to make the architecture of the code better.

The output shoud have the following sections.

1. Design Principles: Share your knowledge of SOLID principles and clean code practices.
2. Analysis Of given code whether refactoring is needed for the requirement
3. Design plan: Create a design plan that addresses the task which reflects the design principles
4. Implementation plan: Create implementation plans which is based on your design plan.[implementation plan should contain complete file path, not file name]
5. Test cases: Design test cases using fake data to validate your implementation plan.


The output should follow the following format
Output format:
```
Design principles:
- [Summary of SOLID principles and clean code practices]

Analysis Of given code from the Code References whether current code satisfies the requirement  
 - Very Detailed Explanation

Design plan: (Based on the Analysis Explanation)
- [Description of the design plan]

Implementation plan:[use file path instead of file name for completeness]
- [Description of the implementation plan]

Test cases:
- [Description of the test cases]
```

Constraints:
1. Adhere to SOLID design principles and python best practices.
   
Existing Code References Just ensure that you didn't forget existing code
llm_workflow_core/registry/workflow_registry.py
"""
workflow_registry.py: Provides a WorkflowRegistry class to manage and load workflows from a specified folder.

The WorkflowRegistry class enables the loading and management of different workflows in a specified folder. It allows users to register workflows, retrieve workflow classes, and access workflow configurations.

Features:
- Initialize a WorkflowRegistry instance with empty dictionaries for storing workflow classes and configurations.
- Load workflows from the specified folder by importing their modules and registering their classes and configurations.
- Register a workflow with a given name, class, and configuration.
- Retrieve the workflow class for a given name.
- Retrieve the workflow configuration for a given name.
"""

from typing import Dict
from importlib import import_module
from pathlib import Path

class WorkflowRegistry:
    """
    A registry for managing and loading workflows from a specified folder.
    """

    def __init__(self):
        """
        Initialize the registry with empty dictionaries for workflows and configurations.
        """
        self.workflows: Dict[str, type] = {}
        self.configs: Dict[str, dict] = {}

    def load_installed_workflows(self, folder: str = "installed_workflows"):
        """
        Load workflows from the specified folder by importing their modules and registering
        their classes and configurations.

        :param folder: The folder containing installed workflows.
        """
        installed_workflows_folder = Path(folder)
        for workflow in installed_workflows_folder.iterdir():
            if not workflow.is_dir():
                continue

            module_path = f"{workflow.parent.name}.{workflow.name}.workflow"
            try:
                module = import_module(module_path)
                workflow_class = getattr(module, "Workflow")
                workflow_config = getattr(module, "WORKFLOW_CONFIG")
                self.register_workflow(workflow.name, workflow_class, workflow_config)
            except (ModuleNotFoundError, AttributeError) as e:
                print(f"Error loading workflow from {module_path}: {e}")

    def register_workflow(self, name: str, workflow_class: type, config: dict):
        """
        Register a workflow with the given name, class, and configuration.

        :param name: The name of the workflow.
        :param workflow_class: The workflow class.
        :param config: The workflow configuration.
        """
        self.workflows[name] = workflow_class
        self.configs[name] = config

    def get_workflow_class(self, name: str) -> type:
        """
        Retrieve the workflow class for the given name.

        :param name: The name of the workflow.
        :return: The workflow class.
        """
        return self.workflows[name]

    def get_workflow_config(self, name: str) -> dict:
        """
        Retrieve the workflow configuration for the given name.

        :param name: The name of the workflow.
        :return: The workflow configuration.
        """
        return self.configs[name]

llm_workflow_core/manager/workflow_manager.py

from ..types.base_workflow import BaseWorkflow
from ..registry.workflow_registry import WorkflowRegistry


class WorkflowManager:
    def __init__(self, workflow_registry: WorkflowRegistry):
        self.workflow_registry = workflow_registry

    def initialize_workflow(self, name: str):
        workflow_class: BaseWorkflow = self.workflow_registry.get_workflow_class(name)
        return workflow_class()

llm_workflow_core/types/base_workflow.py
"""
base_workflow.py: Provides a BaseWorkflow class to be used as a base class for custom workflows.

The BaseWorkflow class offers a foundation for creating custom workflows with unique IDs, status, and configuration.
"""

from enum import Enum
from utils.unique_id_generator import UniqueIDGenerator
from .config_types import WorkflowStagesConfig


class WorkflowStatus(Enum):
    """
    Enumeration representing the status of a workflow.
    """
    Success = 'Success'
    Started = 'Started'
    Failure = 'Failure'


class BaseWorkflow:
    """
    A base class for custom workflows with unique IDs, status, and configuration.
    """

    name = None
    config = None

    def __init__(self):
        """
        Initialize a BaseWorkflow instance with a unique ID and status.
        """
        self.id = UniqueIDGenerator.generate_id()
        self.status = None

    @classmethod
    def set_workflow_name(cls, name: str):
        cls.name = name

    @classmethod
    def set_workflow_config(cls, config: WorkflowTemplateStagesConfig):
        cls.config = config

    def get_workflow_status(self):
        """
        Get the current status of the workflow.

        Returns:
            WorkflowStatus: The current status of the workflow.
        """
        return self.status

    def start_workflow(self):
        """
        Set the status of the workflow to Started and raise a NotImplementedError for derived classes to implement.
        """
        self.status = WorkflowStatus.Started
        raise NotImplementedError("start_workflow method must be implemented in derived classes")

    def execute_stage(self, stage_config: dict):
        """
        Execute a stage in the workflow and raise a NotImplementedError for derived classes to implement.

        Args:
            stage_config (dict): The configuration of the stage to be executed.
        """
        raise NotImplementedError("execute_stage method must be implemented in derived classes")

"""
config_types.py
This module contains the type definitions for the workflow configuration templates.
"""

from typing import TypedDict, Dict, Type, Union
from .base_stage import BaseStage


class StageTemplateConfig(TypedDict, total=False):
    stage_class: Type[BaseStage]
    stages: Dict[str, 'StageTemplateConfig']


class WorkflowTemplateStagesConfig(TypedDict, total=False):
    stages: Dict[str, StageTemplateConfig]



Lets continue to iterate the design plan task again, to have  further 
Analysis Of given code from the Code References whether current code satisfies the requirement, Design plan: (Based on the Analysis Explanation), Implementation plan 
on top of the current iteration



Thank you for rerun the "Optimizing Task Description" Task, can you rerun the "do the design for the ticket description" task? Since new task description is generated


Thank you for consolidating and generating the new requriement. Now lets redo the generate design task again. I will give you
my current codebase again for reference, as the new requirement design plan might need to refactoring existing codes. 


Code References:
src/workflow/config/workflow_config.py
"""
workflow_config.py
The WORKFLOW_CONFIG dictionary defines the structure of the workflow, including stages and substages.
Each stage is defined as a key-value pair, where the key is the stage name and the value is a dictionary containing:
    - 'stage_class': The class representing the stage.
    - 'stages': A dictionary of substages, if any, following the same structure.

For example, the 'requirement' stage has a 'refine' substage with its own class.
"""
from src.workflow.config.workflow_config_types import WorkflowConfigDict
from src.workflow.stages.requirement_stage import RequirementStage
from src.workflow.stages.requirement_refine_stage import RequirementRefineStage
from src.workflow.stages.design_stage import DesignStage
from src.workflow.stages.test_generation_stage import TestGenerationStage
from src.workflow.stages.implementation_stage import ImplementationStage
from src.workflow.stages.testing_stage import TestingStage


from src.workflow.stages.requirement_stage import RequirementStage
from src.workflow.stages.design_stage import DesignStage
from src.workflow.stages.test_generation_stage import TestGenerationStage
from src.workflow.stages.implementation_stage import ImplementationStage
from src.workflow.stages.testing_stage import TestingStage

WORKFLOW_CONFIG: WorkflowConfigDict = {
    'requirement': {
        'stage_class': RequirementStage,
        'stages': {
            'refine': {
                'stage_class': RequirementRefineStage,
            },
        },
    },
    'design': {
        'stage_class': DesignStage,
    },
    'test_generation': {
        'stage_class': TestGenerationStage,
    },
    'implementation': {
        'stage_class': ImplementationStage,
    },
    'testing': {
        'stage_class': TestingStage,
    },
}

src/workflow/automated_coding_workflow.py
"""
automated_coding_workflow.py: Contains the AutomatedCodingWorkflow class, which represents the main entry point for running the automated coding workflow.
"""

from src.input.input_message_handler import get_input_message
from src.llm_integrations.base_llm_integration import BaseLLMIntegration
from src.workflow.config.workflow_config import WORKFLOW_CONFIG


class AutomatedCodingWorkflow:
    """
    A class to represent a fully automated coding workflow.
    """

    def __init__(self, llm_integration: BaseLLMIntegration):
        """
        Initialize the workflow instance and set the initial stage.

        :param llm_integration: An instance of a subclass of BaseLLMIntegration to be used for LLM integration.
        :type llm_integration: BaseLLMIntegration
        """
        self.stages = list(WORKFLOW_CONFIG.keys())
        self.llm_integration = llm_integration

    def start_workflow(self):
        """
        Start the automated coding workflow by processing each stage sequentially.
        """
        for stage in self.stages:
            stage_config = WORKFLOW_CONFIG[stage]
            self.process_stage(stage_config)

    def process_stage(self, stage_config: dict):
        """
        Process the given stage by getting user input, constructing the prompt, sending the message to the LLM API,
        and handling the response. Process substages and sub-substages recursively.

        Args:
            stage_config (dict): The configuration of the current stage.
        """
        stage_instance = stage_config['stage_class'](self)
        user_input = self._get_user_input()
        prompt = stage_instance.construct_prompt(user_input)
       
        response = self.llm_integration.process_input_messages(prompt)
        stage_instance.process_response(response)

        if 'stages' in stage_config:
            for substage_config in stage_config['stages'].values():
                self.process_stage(substage_config)

    def get_workflow_config(self):
        """
        Returns the workflow configuration.

        :return: the workflow configuration.
        """
        return WORKFLOW_CONFIG

    def _get_user_input(self) -> str:
        """
        Get user input based on the given prompt template.

        Returns:
            str: The user input.
        """
        user_input = get_input_message("Enter your input: ")
        return user_input
src/workflow/stages/base_stage.py
"""
base_stage.py

This module contains the BaseStage class.
"""

from abc import ABC, abstractmethod


class BaseStage(ABC):
    """
    BaseStage is the abstract base class for all stages in the automated coding workflow.
    Each stage should inherit from this class and implement the required methods.
    """

    def __init__(self):
        self.prompt = self.construct_prompt()

    @abstractmethod
    def construct_prompt(self) -> str:
        """
        Construct the prompt for this stage.

        Returns:
            str: The constructed prompt for this stage.
        """
        pass

    @abstractmethod
    def process_response(self, response: str) -> None:
        """
        Process the response from the LLM API for this stage.

        Args:
            response (str): The LLM API response as a string.
        """
        pass

src/workflow/stages/requirement_stage.py
"""
requirement_stage.py

This module contains the RequirementStage class, derived from the Stage base class.
"""

from typing_extensions import override
from src.workflow.stages.base_stage import BaseStage

class RequirementStage(BaseStage):


    @override
    def construct_prompt(self) -> str:
        """
        Construct the prompt for the requirement stage.

        Returns:
            str: The constructed prompt for the requirement stage.
        """
        prompt = "Please provide the requirements for the project:"
        return prompt
    
    @override
    def process_response(self, response: str):
        """
        Process the response for the Requirement stage.

        Args:
            response (str): The response from the LLM API.
        """
        # Implement the response processing logic specific to the Requirement stage

To remind you the generate design task, i will paste the task here again.

```Act now like you are an expert in software engineering, with a strong understanding of SOLID principles and clean code best practices. 
Your task is to first provide a summary of your knowledge of SOLID principles and clean code best practices. 

After that, you will do the design for the ticket description. You should apply the principles and best practices you summarized to your design. 

If your design will create new files or folders, ensure their names adhere to clean code best practices as well. 
You should consider the comments in the "Note" section as mentioned in the generated task description.

Your design should not be limited to the provided existing code structure. If
the current code structure does not fits new requirements, you should seek to 
refactor existing code to make the architecture of the code better.

The output shoud have the following sections.

1. Design Principles: Share your knowledge of SOLID principles and clean code practices.
2. Analysis Of given code whether refactoring is needed for the requirement
3. Design plan: Create a design plan that addresses the task which reflects the design principles
4. Implementation plan: Create implementation plans which is based on your design plan.[implementation plan should contain complete file path, not file name]
5. Test cases: Design test cases using fake data to validate your implementation plan.


The output should follow the following format
Output format:

Design principles:
- [Summary of SOLID principles and clean code practices]

Design plan:
- [Description of the design plan]

Implementation plan:[use file path instead of file name for completeness]
- [Description of the implementation plan]

Test cases:
- [Description of the test cases]


Constraints:
1. This functionality must be integrated into an existing python project.
2. Adhere to SOLID design principles and python best practices.
3. Implementation current folder structure:
   