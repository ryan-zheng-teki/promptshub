1. requirement stage
Your task is write a standardised software development ticket for me following the given format. Please put the whole writing in one pre-formatted text block. So i can copy it to github issue. 

Based on the best practice format of writting a ticket, you will give me back the standardized ticket writting. The description i give you is only what i want to achieve, and sometimes a few keywords. Based on what you already know of implementing such feature, you will also make the story more complete. You can also add “implementation plans” as the last section if you know how to implement this ticket.

You can you the following sections

```
Title
Detailed Interaction Flow
Design Plan
Implementation Plan
Acceptance Criteria
Test Cases(each test case should provide fake data)
```

Feature Description:
”We have implemented 
src/workflow/AutomatedCodingWorkflow.py with public interfaces
class AutomatedCodingWorkflow:
    def start_workflow(self):
        """
        Start the automated coding workflow by processing each stage sequentially.
        """
    def process_stage(self, stage_config: dict):
    """
    Process the given stage by getting user input, constructing the prompt, sending the message to the LLM API,
    and handling the response. Process substages and sub-substages recursively.

    Args:
        stage_config (dict): The configuration of the current stage.
    """
Now we want to expose the workflow AutomatedCodingWorkflow via GRPC, so that the workflow
can be started via javascript using js grpc client. We also want to expose one more API from
AutomatedCodingWorkflow to expose the workflow config that this workflow handles to frontend. So that the frontend is able to display the internal nodes of the workflow. This task is 
implement the backend functioality

Constraints:
1. backend is using python

Design principles:
Organize your code into logical components, such as classes or modules.
Use clear and descriptive naming conventions for classes, methods, functions, and variables.
Provide detailed comments and documentation for your code, including:
a. In-line comments explaining the purpose and functionality of each component.
b. Begin your file documentation with a clear statement of the file's purpose and scope.
b.1 Provide a high-level overview of the main class or components within the file.
b.2 Highlight the key features or functionalities of the class or components.
b.3 Keep your documentation clear, concise, and well-organized.
b.4 Use formatting elements, such as bulleted lists, when appropriate to improve readability and organization.
Format your code consistently for readability, and use libraries like colorama when appropriate for enhancing output readability.
Implement error handling and exception handling to make your code more robust and resilient.
Break down complex tasks into smaller, more manageable functions or methods.
Use helper methods and utility functions to abstract away lower-level details.
Leverage asynchronous functionality when appropriate to improve performance and responsiveness.


2. refine requirement
   Thank you for creating the requirement. After reviewing it, I realized I missed some points in the feature description section of the original request. I have updated the feature description in the original request. Please reevaluate the task based on the updated information and provide the revised requirement document. The following is the updated request
   
Your task is write a standardised software development ticket for me following the given format. Please put the whole writing in one pre-formatted text block. So i can copy it to github issue. 

Based on the best practice format of writting a ticket, you will give me back the standardized ticket writting. The description i give you is only what i want to achieve, and sometimes a few keywords. Based on what you already know of implementing such feature, you will also make the story more complete. You can also add “implementation plans” as the last section if you know how to implement this ticket.

You can you the following sections

```
Title
Detailed Interaction Flow
Design Plan
Implementation Plan
Acceptance Criteria
Test Cases(each test case should provide fake data)
```

Feature Description:
”We have implemented automated coding workflow in python backend. 
src/workflow/config/workflow_config.py

The WORKFLOW_CONFIG dictionary defines the structure of the workflow, including stages and substages.
Each stage is defined as a key-value pair, where the key is the stage name and the value is a dictionary containing:
    - 'stage_class': The class representing the stage.
    - 'stages': A dictionary of substages, if any, following the same structure.

For example, the 'requirement' stage has a 'refine' substage with its own class.

WORKFLOW_CONFIG: WorkflowConfigDict = {
    'requirement': {
        'stage_class': RequirementStage,
        'stages': {
            'refine': {
                'stage_class': RequirementRefineStage,
            },
        },
    },
    'design': {
        'stage_class': DesignStage,
    },
    'test_generation': {
        'stage_class': TestGenerationStage,
    },
    'implementation': {
        'stage_class': ImplementationStage,
    },
    'testing': {
        'stage_class': TestingStage,
    },
}

We also have 
src/workflow/automated_coding_workflow.py
This module contains the AutomatedCodingWorkflow class that represents
the main entry point for running the automated coding workflow.

I want to design a solution that can enable me to dynamically insert any other stage into the workflow. For example. After "refine" stage, i want to insert
UploadRequriementToGithub stage. In this way, i can upload the latest requirement to Github automatically. Obviously, the UploadRequriementToGithub stage does 
not have to belong to this repository. It can belong to other repository.

Constraints:
1. backend is using python

Design principles:
Organize your code into logical components, such as classes or modules.
Use clear and descriptive naming conventions for classes, methods, functions, and variables.
Provide detailed comments and documentation for your code, including:
a. In-line comments explaining the purpose and functionality of each component.
b. Begin your file documentation with a clear statement of the file's purpose and scope.
b.1 Provide a high-level overview of the main class or components within the file.
b.2 Highlight the key features or functionalities of the class or components.
b.3 Keep your documentation clear, concise, and well-organized.
b.4 Use formatting elements, such as bulleted lists, when appropriate to improve readability and organization.
Format your code consistently for readability, and use libraries like colorama when appropriate for enhancing output readability.
Implement error handling and exception handling to make your code more robust and resilient.
Break down complex tasks into smaller, more manageable functions or methods.
Use helper methods and utility functions to abstract away lower-level details.
Leverage asynchronous functionality when appropriate to improve performance and responsiveness.


Thank you for the detailed interaction flow, design plan based on the interaction flow.


3. generate design stage
In software engineering, the SOLID principles and clean code best practices are crucial. Please provide a summary of your understanding of SOLID principles and clean code best practices. Additionally, if your design involves creating new files or folders, ensure that their names adhere to clean code best practices. Don't forget
to adjust the import.

This is the current current project folder structure:
```
src
  workflow
     __init__.py
     automated_coding_workflow.py
     config
        workflow_config.py
     stages
        __init__.py
     
```
Based on your understanding of the requirements, provide the file paths and designed code for the relevant files, while ensuring the code adheres to the specified constraints and best practices. Include a Python docstring at the top of each file, and an accompanying method docstring for every public method, in line with Python best practices.
(At this stage, there will be filenames and codes. Then we should automatically update
the files now in IDE => use plugins?)

1. update requirement after reviewing the design and code
   After reviewing the design and code. I want to add update my requirement. 
   
   Requirement Updated:
   "Each stage has to contruct its own prompt. The prompt does not exist in the configuration file. Instead, the prompt for each stage exists in the each stage as configuration.
   "
  Could you update your design, your updated design should also follow SOLID princiles ,clean code best practices, and python best practices.
   In cases you create new folders or files, the folder name and file names should also follow clean code best practices. 

   At last, please output the filepath and the complete code of each updated file in python code block, so i can copy and paste


5. after the redesign, some relevant files are not updated.
   

6. Generate tests from test requirements based on the designed classes
thank you for generating those public interfaces.  All tests should follow pytest best practice. Please give me back what you know of pytest best practice, including the file names. Please generate the test for each test case.

7.requirement consolidatation(change last consolidated to original if update requriement for the first time)
until so far, i have updated the original requirement a few times through our conversations. Could you please
merge all the updated requiremnt to the lasted consolidated one. and give me back a new requirement description. Please follow still the original requriement format.

starting from the second time:until so far, i have updated the last consolidated requirement a few times. Could you please
merge all the updated requiremnt to the lasted consolidated one. and give me back a new requirement description. Please follow still the earliest requriement format.


1. after code update due to requiremnt change, could you check whether relevant file 
src/workflow/automated_coding_workflow should also be updated. Currently it contains 
"""
automated_coding_workflow.py

This module contains the AutomatedCodingWorkflow class that represents a fully automated coding workflow.
"""

from src.communication.input_message_handler import get_input_message, get_input_character
from src.communication.puppeteer_output import PupperteerChat
from src.workflow.config.workflow_config import WORKFLOW_CONFIG

class AutomatedCodingWorkflow:
    """
    A class to represent a fully automated coding workflow.
    """

    def __init__(self):
        """
        Initialize the workflow instance and set the initial stage.
        """
        self.stages = list(WORKFLOW_CONFIG.keys())
        self.chat = PupperteerChat()

    def start_workflow(self):
        """
        Start the automated coding workflow by processing each stage sequentially.
        """
        for stage in self.stages:
            stage_config = WORKFLOW_CONFIG[stage]
            self.process_stage(stage_config)

    def process_stage(self, stage_config: dict):
        """
        Process the given stage by getting user input, constructing the prompt, sending the message to the LLM API,
        and handling the response. Process substages and sub-substages recursively.

        Args:
            stage_config (dict): The configuration of the current stage.
        """
        user_input = self.get_user_input(stage_config['prompt'])
        prompt = self.construct_prompt(stage_config, user_input)
       
        response = self.chat.send_message(prompt)
        stage_instance = stage_config['class']()
        stage_instance.process_response(response)

        if 'substages' in stage_config:
            for substage in stage_config['substages'].values():
                self.process_stage(substage)

    def get_user_input(self, prompt_template: str) -> str:
        """
        Get user input based on the given prompt template.

        Args:
            prompt_template (str): The template for the prompt.

        Returns:
            str: The user input.
        """
        user_input = get_input_message(prompt_template.format("Enter your input: "))
        return user_input

    def construct_prompt(self, stage_config: dict, user_input: str) -> str:
        """
        Construct the final prompt using the stage config and user input.

        Args:
            stage_config (dict): The configuration of the current stage.
            user_input (str): The user input.

        Returns:
            str: The final constructed prompt.
        """
        prompt = stage_config['prompt'].format(user_input)
        return prompt




