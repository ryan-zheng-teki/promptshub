**Role & Objective**:
You are a senior Python developer tasked with updating existing Python code to meet new user requirements.

**Criteria**:
1. Follow PEP8 best practices
2. Follow clean code best practices.

**Methodology**:
The methodology outlines the steps for updating the existing Python code:
1. Analyze the given Python code to understand its current functionality, structure, best practices, frameworks, and other relevant aspects.
2. Analyze the new user requirements against the existing Python code.
3. Engage in an iterative reasoning process, considering multiple perspectives and potential solutions, to identify the necessary changes to achieve the new requirements. Draw upon your intuition and experience as a developer to guide your reasoning, and anticipate potential consequences and implications of the changes. Refine your thoughts as needed to ensure the changes align with best practices and maintain code quality.
4. Implement the identified changes, ensuring the code functions as expected, and present the final updated code in a copiable text block.

[OutputRules]
$RuleStart$
- Initiate each output with a variant of "I am currently...", followed by an action name, step description, major decision point, or any relevant task-specific detail. This flexible approach mirrors the human thought process, capturing the essence of transitioning between major points, steps, or actions, reflecting the dynamic and adaptable nature of human cognition. It reflects the dynamic and adaptable nature of human cognition, accommodating a wide range of contexts and tasks.
- Continuous Logical Flow: Ensure a continuous and logical progression of thoughts, maintaining coherence throughout the discourse. This principle guides the structuring of information to flow smoothly, mirroring the organized way humans tend to process and convey information.
- Meticulous Detail: Maintain meticulous attention to detail, demonstrating the thorough and careful consideration characteristic of human cognitive efforts. This rule emphasizes the importance of precision and accuracy in communication, reflecting the depth of human analysis and understanding.
- Conversational and Personal Language: Use language that is conversational and personal, akin to an individual's internal dialogue. This style brings out the human-like quality of the discourse, making the communication more relatable and engaging.
- Reasoning When Necessary: Include reasoning to precede actions or conclusions. This simulates the human cognitive process of thinking through a problem before arriving at a solution, ensuring that outputs are not only precise but also well-considered and justified.
$RuleEnd$

Follow the algorithm or methodogoy described in the `[Methodology]` section to perform the task, and the output should adhere to the `[OutputRules]`, ensuring a process that mirrors human-like cognitive process.

[ExistingCode]"""
chatgpt_llm_integration.py: Provides a PyppeteerLLMIntegration class to interact with a chat system using Puppeteer.

The ChatGPTLLMIntegration class enables interaction with chat systems that require headless browser interactions. It allows users to send messages, copy chatbot responses to the clipboard, and process a list of input messages.

Features:
- Initialize a PyppeteerLLMIntegration instance with environment variables containing relevant CSS selectors for the chat system.
- Connect to a running browser instance using the Pyppeteer library and find the desired chat page.
- Iterate through a list of input messages, sending them one by one to the chat system.
- Wait for the chatbot's response to be complete and copy it to the clipboard.
- Return the chatbot's response for each input message.
"""

import asyncio
from logging import Logger
import sys
import os
from typing import List, Optional
from colorama import Fore, Style, init
import hashlib
from playwright.async_api import async_playwright
from playwright.async_api import Browser
from playwright.async_api import Page

from chatgpt_llm_provider.browser_launcher import REMOTE_DEBUGGING_PORT, BrowserLauncher
from clipboard.clipboard_manager import wait_for_clipboard_content

# Initialize coloram
init(autoreset=True)

class ChatGPTLLMIntegration:
    """
    PyppeteerLLMIntegration class enables interaction with ChatGPT window in the browser.
    
    Raises:
        ValueError: If any required environment variable is missing.
    """

    def __init__(self, config: Optional[dict] = None) -> None:
        required_keys = ["BROWSER_URL", "DOMAIN", "SELECTORS_TEXTAREA_SELECTOR", "SELECTORS_COPY_BUTTON_SELECTOR", "SELECTORS_MESSAGE_CONTAINER_SELECTOR"]
        for key in required_keys:
            if key not in os.environ:
                raise ValueError(f"Missing required environment variable: {key}")

        self.browser_url: str = os.environ["BROWSER_URL"]
        self.domain: str = os.environ["DOMAIN"]
        self.textarea_selector: str = os.environ["SELECTORS_TEXTAREA_SELECTOR"]
        self.copy_button_selector: str = os.environ["SELECTORS_COPY_BUTTON_SELECTOR"]
        self.response_container_selector: str = os.environ["SELECTORS_MESSAGE_CONTAINER_SELECTOR"]
        self.browser: Optional[Browser] = None
        self.page: Optional[Page] = None

    async def process_input_messages(self, input_messages: List[str]) -> List[str]:
        """
        Process input messages using Puppeteer, send them to the chat system, and return the chatbot's responses.
        """
        responses: List[str] = []
        for message in input_messages:
            response: str = await self._send_message_and_wait_for_response(message)
            responses.append(response)
        return responses

    async def initialize(self) -> bool:
        """
        Initialize the PyppeteerLLMIntegration instance by connecting to the browser and finding the target page.
        """
        try:
            await BrowserLauncher.launch_browser()
            async with async_playwright() as playwright:
                endpoint_url = f"http://localhost:{REMOTE_DEBUGGING_PORT}"
                # Assuming 'self.playwright' typo was meant to be 'playwright' in your original code
                self.browser = await playwright.chromium.connect_over_cdp(endpoint_url)
                # Assuming you want the first context and its first page, otherwise adjust accordingly
                self.context = self.browser.contexts[0]
                self.page = self.context.pages[0]
                await self.perform_booking_navigations()
        except Exception as e:
            Logger.error(f"Error navigating to site: {str(e)}")
            # No need for explicit cleanup here; context manager handles it
            raise

        pages: List[Page] = await self._get_browser_pages()

        target_page: Optional[Page] = await self._find_target_page(pages)

        if target_page is None:
            print(Fore.RED + "Desired page not found." + Style.RESET_ALL)
            return False

        self.page = target_page
        return True

    async def _get_browser_pages(self) -> List[Page]:
        """
        Get a list of all pages in the connected browser.
        """
        return await self.browser.pages()

    async def _find_target_page(self, pages: List[Page]) -> Optional[Page]:
        """
        Find the target page with the desired chat system based on the domain.
        """
        for page in pages:
            url: str = page.url
            if self.domain in url:
                return page
        return None



[NewRequirements]
Instead of looking for the target page, let's go to page which is specified by the domain.