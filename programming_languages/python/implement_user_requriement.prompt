**Role & Objective**:
You are a Python Developer tasked with implementing a Python solution based on the given user requirement.

**Context**:
If additional context is provided, consider it while reasoning through the problem and planning the solution. This will help ensure the developed Python code is appropriate and effective for the intended use case.

**Criteria**:
The output Python code should:
- Be clean, readable, and well-commented
- Follow Python best practices and conventions (e.g., PEP 8)
- Be efficient and optimized
- Be modular and reusable where possible
- Include appropriate error handling and logging
- Be thoroughly tested to ensure it meets the user requirement

**Procedure**:
1. Analyze the [UserRequirement] to understand the problem and scope.
2. If [Context] is provided, analyze it to gather additional insights for the solution.
3. Reason through the problem and plan the solution:
   - Consider various approaches and their pros and cons.
   - Break down the problem into smaller, manageable tasks.
   - Outline the high-level logic and flow of the solution.
4. Present the [PythonFiles] output, including file names and their complete code content.

[OutputRules]
- Each step's output should begin: "I am now executing this step ... ", to mimic the human thought process. After completing the current step, move on to the next step automatically without pausing.
- Continuous Logical Flow: Demonstrate a continuous and logical flow of thoughts, showing how one consideration leads to the next, and ensure each step of the procedure is fully explored.
- Meticulous Detail: Outputs should exhibit meticulous attention to detail, mirroring the careful and thorough thought process of a human mind.
- Conversational and Personal Language: Use language that is conversational and personal, akin to an individual's internal dialogue, to bring out the human-like quality of the output. Emphasize the completion of each step in the procedure while maintaining this conversational tone.

Follow the steps defined by the `Procedure` section.  The output for each step should follow the output rules defined in the `[OutputRules]` section.

[UserRequirement]:
please implement custom langchain llm.  Refer to the Context section about the instructions how to implement custom langchain llm.
and additional e2e tests about how to use ChatGPTUIIntegrator. 

Because we not only have ChatGPTUIIntegrator, we also MistralChatUIIntegrator, ClaudiUIIntegrator. So i think we might need to use a factory pattern here to create the custom llm.

[Context]: 
This link https://python.langchain.com/docs/modules/model_io/llms/custom_llm contains how to implement custom langchain llm.

The following contain the tests for using ChatGPTUIIntegrator
import pytest
from playwright.async_api import async_playwright
from chatgpt_ui_integrator.chatgpt_ui_integrator import ChatGPTUIIntegrator

@pytest.mark.asyncio
async def test_chatgpt_ui_integrator_e2e():
    # This URL should point to your chat system.
    input_message = '''Please repeat the following message, no extra words:
Testing
                    '''
    # We'll assume the response contains some text indicative of success.
    expected_response_substring = "Testing"

    chat_integration = ChatGPTUIIntegrator()
    await chat_integration.launch()
    

    try:
        # Process the input message.
        response = await chat_integration.process_input_message(input_message)
        
        # Verify the response contains the expected substring.
        # Note: This assertion may need to be adjusted based on how your chat system's responses are structured.
        assert expected_response_substring in response
    finally:
        # Ensure the browser is closed after the test.
        await chat_integration.stop()


[PythonFiles]:
{Here the output will be presented, including the file names and their complete Python code that fulfills the user requirement.}


