You are an editor and proofreader. Your task is to refine and enhance a technical article, ensuring it is grammatically correct, logically structured, and free of redundancies.

**Criteria**:
1. The article must be grammatically flawless.
2. The logical flow of content must be coherent and natural.
3. Each paragraph should follow a logical sequence and be internally consistent.
4. Avoid redundancy in sentences to maintain clarity and brevity.

**Procedure**:
1. **Grammar Correction**: Review the article for any grammatical errors and correct them. Pay attention to common issues like punctuation, verb tense agreement, and sentence structure.
2. **Assessing Logical Flow of Content**: Evaluate the overall structure of the article. Ensure that the progression of ideas or concepts is logical and that transitions between sections are smooth.
3. **Paragraph Structure Improvement**: For each paragraph, check that it focuses on a single idea or concept and that the sentences within it are logically connected and contribute to the main point of the paragraph.
4. **Elimination of Redundancies**: Identify and remove any redundant sentences or phrases to ensure conciseness and clarity.
5. **Presentation of the Final Version**: Compile the revisions from the previous steps and present the final, polished version of the article, ensuring it meets all criteria and is ready for its intended audience.


Please follow the steps defined in the Procedure. Ensure meticulous step-by-step deep thinking and comprehensive reasoning for each step.

[Article]
$start$
When we have code design specifications comprehensively documented for a software module in one application, we would naturally like to apply new requirements to this module. Of course, this is again driven by a prompt. I put the prompt here directly. We would like to ask LLM to figure out the changes that need to be made based on the new requirement and create subtasks based on the planned changes. 
Then we submit each subtask to LLM to make LLM implement the subtasks, given the original code for each component(file). The return of each subtask is the updated code for that specific component(file).
The more reliably this process works, the less work human has to be involved.
$end$





Version 2:
You are a Technical Editor. You are tasked with refining a technical article for grammatical accuracy, logical coherence, and optimal paragraph structure.

**Criteria**:
1. Correct all grammatical and syntax errors for professional readability.
2. Ensure a logical sequence and coherence in the overall content structure.
3. Structure paragraphs to be clear, logical, and free of redundancies.

**Procedure**:
1. **Grammar and Syntax Review**: Carefully review each sentence for grammatical accuracy, focusing on punctuation, verb tense consistency, and correct usage of technical terms.
2. **Summarize Paragraph Content**: For each paragraph, briefly summarize its main content to understand its purpose within the article.
3. **Assess Logical Flow of Paragraphs**: With the summarized content, evaluate whether each paragraph logically follows the previous one and sets the stage for the next, ensuring a coherent narrative or argument.
4. **Paragraph Structure Analysis**: Within each paragraph, ensure that every sentence contributes to the paragraph's main idea, enhance clarity, and remove any redundant phrases or information.
5. **Final Review**: Perform a comprehensive review of the entire article to ensure that all changes made contribute positively to its readability, technical accuracy, and overall coherence.

By meticulously following these steps, you will enhance the clarity, coherence, and professional quality of your technical article. If there are any specific concerns or additional details you would like to address during the editing process, please feel free to include them.


Version 3: Understand the content of the user's writting first.
You are an editor and proofreader tasked with refining a diverse range of articles. Your primary goal is to understand the author's intent and ensure the article accurately conveys it.

**Criteria**:
1. Achieve grammatical accuracy.
2. Clarify and accurately convey the author's intended message.
3. Maintain logical flow and coherence in the content.
4. Eliminate redundancies for clarity.

**Procedure**:
1. **Understanding Author's Intent**: Understand the author's main objectives and intended message of the article.
2. **Content Clarification**: Revise the article to better articulate the author's ideas, ensuring accuracy and clarity.
3. **Final Presentation**: Present the final version, ensuring it accurately reflects the author's intended message and meets all criteria for its intended audience.

Please follow the steps defined in the Procedure. Ensure meticulous step-by-step deep thinking and comprehensive reasoning for each step.

[Article]
$start$
When we have code design specifications comprehensively documented for a software module in one application, we would naturally need to apply new requirements to this module over the life cycle of the application. Of course, this is again driven by a prompt. I put the prompt here directly. This prompt will ask LLM to figure out the changes that need to be made on the existing code base based on the new requirement and create plan of change for each applicable component mentioned in the code documentation.
Then we will use another prompt to instruct LLM to create subtask for each planned change. 
Then we submit each subtask to LLM to make LLM implement the subtask, given the original code for each component(file). The return of each subtask is the updated code for that specific component(file).
This streamlined process is driven by multiple prompts. The more reliably this process works, the less work human has to be involved.
$end$





Version 3:

You are a Software Architect. You are tasked with refining a technical article given to you.

**Context**:
The primary audience for these articles is software developers. In technical writing, there is a distinct preference for simplicity over complexity in language. This approach contrasts with literary works or novels, where language is often chosen for its aesthetic qualities, sometimes using less common words like 'scrutinize' instead of more straightforward terms such as 'understand'. This stylistic choice in literature prioritizes artistic expression, while technical writing, in contrast, favors strong logical coherence and clarity. Technical articles employ causal reasoning and structured argumentation, emphasizing these aspects to facilitate reader understanding and engagement.

**Criteria**:
1. Use simple and clear language to ensure accessibility for a broad audience.
2. Keep content factual and technically accurate, avoiding complex jargon.
3. Focus writing on practical, straightforward communication, rather than mimicking professional literature or novels.
4. Aim for a non-specialist approach, making technical subjects understandable to readers without specialized knowledge.

**Procedure**:
1. Summarize each paragraph of the given `[UserArticle] using a short concise sentence`.
2. Assess the logical flow between the summarized paragraphs and identify any redundancies across them, to facilitate the merging or repositioning of paragraphs that discuss similar topics.
3. Based on previous analysis, reorganize paragraphs for coherence in a copiable text block.
4. Present the final complete article with strong logical coherence and content flow in a copiable text block. 

**OutputFormat**:
- The output should strictly adhere to the original procedure's step objective, formatting each step with the exact title as specified in the procedure, and ensuring the content under each step directly relates to the step's purpose, thus maintaining clarity and consistency.
  Example:
  Step 1: Summarize each paragraph under '[Paragraph Summaries]'..
  {Elaborate on the analysis or action taken in this step, ensuring it aligns with the step's title.}

Please follow the steps defined in the Procedure. Ensure meticulous step-by-step deep thinking and comprehensive reasoning for each step. The output should adhere to the defined output criteria from the `OutputFormat` section.

[UserArticle]
$start$

The user suggests that in the future, software development will parallel book writing, driven by the extensive use of large language models throughout the software engineering process. This includes stages from requirement engineering to deployment. Effectively employing these models requires providing them with coherent and structured contexts, essential for navigating different development phases.

In software engineering, the process of modularization originates from requirement categorization. This involves organizing numerous requirements into categories based on similar functionalities that achieve a specific purpose. These categories then guide the modular architecture in software design.

Software architects play a crucial role in understanding and grouping requirement entries into broader categories, a task that can be significantly aided by large language models. Additionally, the interaction among different modules or categories, which collectively fulfill the application's functionality, is vital. This involves using special symbols or catalog pages to list modules and describe their interactions and contents.


The user continues discussing the integration of individual requirement entries into specific software modules, comparing it to organizing a book's chapters. The process involves designing APIs for each module, ensuring these designs fulfill all module requirements without immediate implementation.

Post-API design, the focus shifts to detailing each API's functionality, leading to the creation of implementation tasks. Clear API descriptions, linked to their original requirements, are crucial. This clarity in documentation and design enhances the effectiveness of large language models in automating implementation tasks.

Furthermore, the user highlights the role of unit testing, which benefits from well-structured API designs and comprehensive documentation. Such thorough preparation enables large language models to contribute more effectively, particularly in implementation and testing phases of software development.


The user describes the next stages in software module development, focusing on the period after the API design is completed for each module. The API designs are documented for individual modules. Subsequently, implementation tasks are generated, resulting in the creation of files. These files contain the implementations of the APIs and are organized under their respective modules. This process illustrates a structured approach in software development, with each module being a distinct entity with its dedicated APIs and implementations.


In software development, there exists a hierarchical navigation process, comparable to navigating a book. This process begins at the application level, encompassing various modules, and progresses into specific requirements and API designs of each module.

Upon the introduction of a new requirement, the procedure involves analyzing module descriptions to pinpoint the relevant module for modification. This is achieved by constructing vectors for each module's description. Large language models are utilized, fed with both existing module requirements and new requirements, to aid in reasoning and suggesting changes. This process culminates in the generation of requirement update documentation.

The established linkage between the module's API design and its requirements documentation facilitates efficient updates to APIs in light of new requirements. As each API is linked to its corresponding location in the file system, the model can effectively navigate to the pertinent files for implementation updates. This systematic approach establishes a comprehensive navigation path, providing a structured context for large language models in software engineering.

The software development process is described as a structured system akin to navigating through a book. This system enables the integration of large language models at various stages, such as updating requirements, modifying APIs, and implementing codebase changes. The well-structured documentation within this system provides a clear reasoning path for the model.

The importance of detailed documentation is emphasized, as it facilitates the creation of efficient prompts for the large language model. These prompts provide essential background information, guiding the model to focus on specific tasks. The model operates similarly to editing a specific chapter or section in a book, allowing for precise adjustments in the software's knowledge base.
$end$



Large language models will play a significant role in future software development, akin to the process of writing a book. This involves stages from requirement engineering to deployment, requiring coherent and structured contexts.

Modularization in software engineering begins with categorizing requirements, which guide software design. Software architects use large language models to categorize requirements and understand module interactions.

The integration of individual requirements into software modules involves API design, similar to organizing a book's chapters. Post-API design, the focus shifts to detailing API functionality, leading to the creation of implementation tasks.

Unit testing benefits from well-structured API designs and comprehensive documentation, which are enhanced by large language models. This thorough preparation enables the models to contribute effectively in the implementation and testing phases.

The stages after API design involve documenting APIs for individual modules, generating implementation tasks, and file creation. This process illustrates a structured approach in software development, where each module is a distinct entity with its dedicated APIs and implementations.

Software development involves a hierarchical navigation process, starting from the application level to specific requirements and API designs. Upon the introduction of new requirements, large language models analyze module descriptions and suggest changes.

A structured approach in software development links module's API design to requirements, aiding in efficient updates. The established linkage facilitates updates to APIs in light of new requirements, with each API linked to its corresponding location in the file system.

Detailed documentation is crucial for creating efficient prompts for large language models, enabling precise software adjustments. These prompts guide the model, similar to editing a specific chapter or section in a book.



**Software Application Knowledge Tree (Book-Like Structure)**

1. **Application Overview (Book Cover)**
   - Title: Application Name
   - Summary: Brief Description of the Application

2. **Table of Contents (Modules Overview)**
   - List of Major Modules (Chapters)
   - Brief Description of Each Module

3. **Modules (Chapters)**
   - Each module represents a chapter in the book.
   - Contents of each Module (Chapter):
     1. **Module Requirements (Chapter Introduction)**
        - Detailed Requirements of the Module
        - Overview of Module's Purpose and Functionalities
     2. **Public API Section (External Interface)**
        - Description of Public APIs
        - Integration Guidelines
     3. **Detailed Design (Comprehensive Overview)**
        - Description of Internal APIs
        - In-depth Coverage of Public APIs
        - Internal Structure and File Organization
     4. **Implementation Details (Implementation Specifics)**
        - Code Implementations
     5. **Subtasks (Implementation Breakdown)**
        - Specific Implementation Tasks
        - Reference to File Path for Each Task
     6. **Unit Testing (Quality Assurance)**
        - Test Cases Specific to the Module
        - Documentation of Testing Procedures
        - File Path for Each Test Case
     7. **Integration Testing (Inter-Module Testing)**
        - Testing Procedures for Module Interactions
        - File Paths for Integration Test Scripts

4. **Deployment (Application Launch)**
   - Deployment Strategies and Best Practices
   - Environment Setup and Configuration
   - Version Control and Release Management

Prompting.










The advent of large language models has significantly altered traditional software engineering practices and impacted various industries. The efficacy of these models largely depends on the design of structured prompts, which serve as task-specific instructions. These prompts should be logically organized and sufficiently detailed to guide the models effectively. However, optimizing prompts presents challenges, including determining the appropriate level of detail and managing the costs associated with their evaluation. Despite these challenges, the optimization of prompts is a critical component, with humans playing a pivotal role in assessing and refining these prompts to ensure their effectiveness.

To iteratively improve prompts for large language models, the process begins with the creation of a meta prompt. This meta prompt serves to generate an initial prompt by first identifying the user's task, establishing the role and objective, setting the context, and outlining the procedure. The initial prompt, often imperfect, is then refined through a critical evaluation of its components, identifying and rectifying any evident flaws. This iterative process not only enhances the prompt itself but also offers insights into potential improvements for the meta prompt, thereby increasing the effectiveness of future prompts.

The process described involves an iterative refinement of prompts using a large language model, primarily ChatGPT. Initially, noticeable errors or unsatisfactory elements within the original prompt are corrected. The revised prompt is then submitted to the language model for evaluation. The output is critically analyzed, with a focus on identifying deficiencies. To articulate the desired changes more effectively, both the original prompt and the model's output are incorporated into an evaluation prompt, which includes specific feedback. This step guides the language model towards producing improved content or enables an evaluation based on the provided feedback, with a particular emphasis on addressing areas of dissatisfaction. The iterative nature of this process, involving continuous feedback and modification, results in text that more accurately reflects the intended meaning. Elements of this text are subsequently integrated back into the original prompt for further processing. This cycle of evaluation and refinement is repeated as necessary to extract text that best represents the desired outcome.


The method discussed involves the use of a refinement prompt as an integral part of enhancing the quality of initial prompts. This refinement prompt is capable of processing the original prompt alongside specific user requirements. It is particularly useful when the user identifies a need for modification in the original prompt but faces challenges in expressing these changes in formal language. In such instances, the user employs informal or rough language to convey their intentions. The refinement prompt is then utilized to implement specific modifications, applicable when the output from the language model is unsatisfactory, lacks detail, or requires supplementary information. The decision to modify is contingent upon the specific requirements of the task.

A key strategy in this method is the precision of feedback regarding dissatisfaction with the original prompt. Generalized feedback can lead to the language model making extensive, potentially unintended changes. Conversely, specifying particular sections or sentences that need improvement allows for a more controlled and incremental enhancement process. This focused approach fosters gradual improvements in the original prompt, guiding it towards a more refined and accurate representation of the desired outcome.


The proposed experiment involves the application of a generic code design template across various programming languages. This template, while broadly applicable, includes specific details such as methods, APIs, and attributes crucial for design. Although the template may resemble a class in object-oriented programming, its intention is to be universally applicable, encompassing languages that support both functional and object-oriented programming styles.

A challenge is identified when processing this generic template through a large language model. The model tends to interpret the components of the template as classes, which is not always the most suitable approach for languages with multiple programming paradigms. The objective of the experiment is to adapt this generic code design documentation into a language-specific template, for instance, for Python. This adaptation process requires a significant amount of creativity and ideation, which can be time-consuming. The experiment aims to utilize the creative potential of a large language model to facilitate and improve the efficiency of this transformation process.

The optimization process begins with the creation of an initial prompt, utilizing a specialized meta prompt. This meta prompt is tasked with a specific challenge: to convert a generic code design template into one that is language-specific. It accomplishes this by determining the task's domain and generating procedures and context relevant to the task, thereby producing the initial prompt.

Following the creation of this initial prompt, the process involves a thorough review to identify and correct clear deficiencies. These improvements are made prior to engaging with a large language model. Subsequently, the refined prompt is submitted to the model. The primary focus at this stage is to analyze the model's output, which often necessitates additional adjustments, particularly in terms of the prompt's structural aspects.
$stop$










5. Refine each paragraph individually in '[Paragraph Optimization]'.
6. Adjust style and tone uniformly in '[Style and Tone Adjustment]'.

