**Software Application Knowledge Book (Book-Like Structure)**

1. **Application Summary**
   - { summary of the Application, which captures the essense of the application }

2. **Technology Specifications (Framework and Libraries)**
   - Application Type: {here is the application type}
   - Frameworks and Libraries, including versions and configurations

3. **Architecture** 
   - List of Major Modules (Chapters). 
   - Brief Description of Each Module
   - How the modules interact with each other

4. **Global Configuration**
   - Here we put some global configurations{not sure what to put here now}

5. **Design Pattern**
   - Here we describe some design patterns we use. For example, to access the database, we have used some design patterns, so when we are developing certain module, this kinda global information can be sent as context information. This will drive the overall design.
   - { repository pattern } Please refer to the 

6. **Modules (Chapters)**
   - Each module represents a chapter in the book.
   - **Table of Contents (Modules Overview)**
     - List of Major Modules (Chapters)
     - Brief Description of Each Module
   - Contents of each Module (Chapter):
     1. **Module Requirements**
        - Detailed Requirements of the Module
        - Overview of Module's Purpose and Functionalities
        - Requirements dependencies using triggerd by and trigering statement.
     2. **Public API Section**
        - Description of Public APIs
        - Integration Guidelines
     3. **Detailed Design**
        - Description of Internal APIs
        - In-depth Coverage of Public APIs
        - Internal Structure and File Organization
     4. **Implementation Details (Implementation Specifics)**
        - Code Implementations
     5. **Subtasks (Implementation Breakdown)**
        - Specific Implementation Tasks
        - Reference to File Path for Each Task
     6. **Unit Testing (Quality Assurance)**
        - Test Cases Specific to the Module
        - Documentation of Testing Procedures
        - File Path for Each Test Case
     7. **Integration Testing (Inter-Module Testing)**
        - Testing Procedures for Module Interactions
        - File Paths for Integration Test Scripts

7. **Non-Modular Components**
   - here we put the non-module component, what they are, what are their usage. Because in one application, we not only have 
   - **main.py (Entry File)**: Introduction to the application's entry point, outlining its role in initializing modules, orchestrating the flow between configuration reading, website navigation, and notification handling.

8. **System Testing (Application-Level Testing)**
   - Testing Procedures for the Entire Application
   - Test Cases for End-to-End Functionality
   - Documentation of System Testing Processes
   - File Paths for System Test Scripts

9. **Deployment (Application Launch)**
   - Deployment Strategies and Best Practices
   - Environment Setup and Configuration
   - Version Control and Release Management

10. **Data Management and Storage**
    - Discusses how `config.json` is utilized for dynamic configuration management and details the structure for maintaining logs in the "logs" folder.






### Functional Requirement Template
1. **Requirement Name**: A concise, descriptive title that summarizes the main action or objective of the requirement.

2. **Triggered by**: States the exact name of the functional requirement that must be completed to initiate this requirement, establishing a direct dependency link.

3. **Input(s)**: Description of the input(s) required for the requirement, including the source of each input.

4. **Process**: Detailed description of the process or functionality that occurs in response to the trigger.

5. **Output**: The expected result or effect produced by the action.

6. **Triggering**: Names the functional requirement(s) that are activated upon completing this requirement, indicating the next steps in the process.



Example: 
**Requirement Name**: Invoice Generation After Payment Confirmation

**Triggered by**: Confirmation of payment received from the user.

**Process**: Upon receiving a signal that payment has been successfully processed, the system retrieves the order details and user information to generate a detailed invoice. This invoice includes the date, transaction details, items purchased, total amount paid, and applicable taxes. The invoice is then formatted according to the company's branding guidelines.

**Output**: A PDF invoice, ready to be emailed to the customer and stored in the database for record-keeping.

**Triggering**: Initiates the Email Invoice to Customer process, sending the generated invoice to the customer's email address on file.

**Dependencies**: 
- **Payment Processing**: A confirmation signal from the payment processing system is necessary to trigger the invoice generation process.
- **Order Management**: Access to the latest order details and user information stored in the order management system.

