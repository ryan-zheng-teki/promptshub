You are a writing refinement expert. Your task is to improve the writing provided in the `[Writing]` section between `$start$` and `$end$` tokens, based on the `[UserRequest]` section.

[Context]
Most of the writting is well-written, but only some minor parts can be improved.
The optimized writting will be used by large language model like ChatGPT.

[Criteria]
- Avoid excessive optimization. For example, replacing straightforward words with more complex synonyms might degrade the performance when processed by ChatGPT.
- Prioritize explicitness and clarity over complexity.

Follow the steps below:
1. **Analyze the Writing**:
   - Examine the writing to grasp its content and goals.
   - Identify the domain of the writing.

2. **Analyze the User Request**:
   - Understand the specific concerns of the user based on the writing.

3. **Engage in a Dialogue to Resolve Ambiguities**:
   - **Identify Potential Questions or Ambiguities**: 
     * Based on the provided information, list out potential areas of uncertainty.
   - **Self-Reasoning for Identified Ambiguities**:
     * Attempt to resolve as many ambiguities as possible internally.
   - **Are there genuine ambiguities left?**
     * **Yes**: 
       + Pose specific questions to the user for unresolved ambiguities.
       + Wait for the user's feedback.
       + Re-analyze the user's response.
     * **No**: 
       + Proceed to Step 4.

4. **Plan Improvements**:
   - Plan the necessary improvements considering the domain, writing's content, and clarified request. Keep in mind the following principles:
     - **Clarity & Accuracy**: Use precise and appropriate terminology for the domain or context, ensuring word choices align with accepted norms. The content should be clear and convey its intended meaning.
     - **Succinctness & Simplicity**: Be concise, avoiding unnecessary verbosity, and choose common and straightforward words over less common terms.
     - **Logical Structure & Coherence**: Organize content to follow a clear and logical sequence, ensuring smooth transitions and maintaining internal coherence.
     - **Consistency**: Maintain a steady style and tone.

5. **Present the Refined Writing**:
   - Apply the improvements planned in step 4 and present the refined writing in a copiable text block.


[Writing]
$start$
**Component Design Specification Template**

**Introduction:**
*Provide a brief overview of the purpose of this document, the system or feature it relates to, and any other context that a reader might need to understand the following content.*

---

**Components:**

---

**1. Component Name:** 
*Derived from the primary subject of the requirement or a more intuitive name that best represents the component's functionality.*

**1.1 Description:**
*A brief description of the component's purpose and its role in the system.*

**1.2 Operations/Methods:** 
*Derived from the actions or behaviors mentioned in the requirement.*

- **Operation Name:** Description of the operation and its purpose.

- **Operation Name:** Another operation's description.

**1.3 Properties/Attributes:** 
*Derived from specific characteristics or details related to the subject.*

- **Property Name:** Description of the property and its significance.

- **Property Name:** Another property's description.

**1.4 Dependencies:** 
*List of other components or services this component might rely on.*

**1.5 Assumptions:**
*Any assumptions made while designing the component based on the requirements.*

**1.6 Constraints:**
*Any limitations or restrictions that should be kept in mind for this component.*

---

*Continue the pattern for each additional component: 2. Component Name, 2.1 Description, and so forth...*
$end$

[UserRequest]
I think the structure of the template can be improved, for example numbering system. Let me give one 
example template in the `[ExampleTemplate]` section.  If you look at the template, you see that 
it has a very good numbering system. Header, subheader etc.

[ExampleTemplate]
**1. Title**: 
- Description of the update to the module requirements specification

**2. Module Requirements Specification Being Updated**:

**2.1. Title**: 
- Name of the module requirements specification being updated

**2.2. Abbreviation**:
- Shorthand abbreviation of the module.

**2.3. Version**: 
- Version of the module requirements specification being updated

**2.4. Original Specification Summary**:
- Main functionalities or aspects of the requirements specification being updated

**3. Caused By Module**:

**3.1. Title**: 
- Name of the driving module or change

**3.2. Abbreviation**:
- Shorthand abbreviation of the module it integrates with or depends upon.

**3.3. Version**: 
- Version of the driving module or change

**3.4. Functionality Provided**:
- Functionalities or changes introduced by the driving module or change

**4. Symbols & Usage**:
In this module, specific symbols are used to highlight, classify, or provide additional context to certain items. This section explains the significance of each.

- **[⇌ CausedByModule_Abbreviation]**: Denotes functionalities or interactions that directly involve the module indicated by the abbreviation of the "Caused By Module".

<Add additional symbols or terminologies as they are introduced in the module.>

**5. Integration/Update Details**:

**5.1. Specifications**:

**5.1.1. Functional Specifications**:

- **<Category (e.g., File Operations)>**:

  **Modifications**:

  - **Original**: Upload files to the cloud
    - **Reason/Driven By**: Specific functionality from the driving module that led to the update
    - **Updated**: [⇌ CausedByModule_Abbreviation] Updated functionality or description
  
  **Additions**:

  - **New Specification**: Share files via link
    - **[+]**: [⇌ CausedByModule_Abbreviation] Description of the new specification
    - **Reason/Driven By**: Specific functionality from the driving module that led to the addition
  
  **Removals**:

  - **Original**: Rename files
    - **[−]**: [⇌ CausedByModule_Abbreviation] Description of the removed specification
    - **Reason/Driven By**: Specific reason or functionality from the driving module that led to the removal

  (Continue detailing changes for other specifications within the category and then for other categories within Functional Specifications)

**5.1.2. Technical Specifications**:

- **<Category>**:

  ... (Structure remains the same as above for Functional Specifications)

  (Continue detailing changes for other categories within Technical Specifications as necessary)













**Introduction to the Prompting Procedure Programming**:
The Prompting Procedure Programming, born from the synergy between conventional programming and natural language, aims to provide a more structured approach to interacting with large language models like ChatGPT. The core principle behind its inception is the amalgamation of the logical precision of traditional programming languages and the comprehensibility of natural language. This combination ensures clearer instructions to the model, thereby enhancing the efficiency and accuracy of its outputs.

**Why the Need for the Prompting Procedure Programming?**:
While large language models are proficient in understanding and generating natural language, there are instances where unstructured prompts can lead to ambiguous or incorrect results. By introducing structured constructs like loops, conditions, and directives, the Prompting Procedure Programming aids in providing clearer and more defined instructions, effectively reducing the room for error.

**Language Elements and Their Descriptions**:
1. **GLOBAL DIRECTIVE**:
- **Definition**: A high-level command that sets the tone or provides overarching instructions for the entire procedure.
- **Usage**: Ensures that the entire procedure follows a consistent set of rules or guidelines.

2. **DIRECTIVE**:
- **Definition**: Specific guidelines or rules tailored for a particular action.
- **Usage**: Provides a more granular level of instruction for actions, ensuring they adhere to specific conditions or requirements.

3. **Global Variables**:
- **Definition**: Variables that are accessible throughout the entire procedure.
- **Usage**: Initialized at the beginning of the procedure and can be utilized in any subsequent step or action.

4. **Step**:
- **Definition**: Represents a distinct operation with a clear objective in the procedure.
- **Usage**: Used to signify a particular segment or phase in the prompting code.

5. **Action**:
- **Definition**: A sub-component within its parent step that denotes a specific task to be executed.
- **Usage**: Details out the exact operations to be performed.
- **Example**:
```
content, objectives = Action: DISSECT the promptContent TO grasp ITS content AND objectives
```

6. **IF and ELSE**:
- **Definition**: Conditional constructs used to introduce a condition (IF) and provide an alternative course of action (ELSE).
- **Usage**: Enables conditional execution of steps or actions based on specified criteria.

7. **LABEL**:
- **Definition**: Marks a specific line or point in the procedure.
- **Usage**: Acts as a reference point for JUMP directives.

8. **JUMP**:
- **Definition**: Directs the execution to jump to a specified labeled line.
- **Usage**: Used in conjunction with LABEL to control the flow of execution.

9. **EXECUTION PLAN**:
- **Definition**: A structured sequence of steps or actions that outlines the flow and order of execution within a designated block.
- **Usage**: Mirrors the cognitive process humans undergo when mapping out tasks before performing them.

10. **RETURN**:
- **Definition**: A command used to send back the result from a specific step.
- **Usage**: Allows the returned value to be sent as an argument to subsequent steps or actions. 
- **Example**:
```
Step AnalyzeThePrompt(promptContent):
    content, objectives = Action: DISSECT the promptContent TO grasp ITS content AND objectives
    RETURN content, objectives
```

**Current State of the Language**:
As of now, the Prompting Procedure Programming encompasses only the above-defined elements. There aren't any additional constructs or components introduced yet. This ensures simplicity and ease of understanding for users but also paves the way for potential extensions in the future, based on evolving needs and user feedback.
