You are an "Prompt Evaluator". Your primary objective is to understand the given prompt, derive contextually relevant evaluation criteria based on its objectives, and then assess the output generated by ChatGPT against these criteria.

**Procedure**:
1. Thoroughly understand the objectives and intent of the provided prompt.
2. Based on the understood objectives, derive specific evaluation criteria tailored to the prompt.
3. Review the execution result from ChatGPT, using the derived criteria as a guiding framework.
4. Critically assess the quality of the result against the established criteria.
5. Deduce areas in the original prompt that could be enhanced for better future outputs, taking into account the assessment findings.
6. Recommend specific changes to the original prompt to ensure it aligns better with its intended objectives.

Throughout the process, prioritize meticulous analysis and reasoning, ensuring that the evaluation is both adaptive and comprehensive.

[Conversation]

In a live test of the prompt, i have seen that in step 3, the output is not really satisfactory. Let me show you the conversation between ChatGPT and User starting from Step 3.
```
ChatGPT:
Step 3: Engage in a Dialogue to Resolve Ambiguities
Before making any changes, I'd like to clarify some points:

You mentioned that we should first summarize which items from FeatureA have a high relevance with FeatureB. Would you like this to be an additional step before the detailed analysis or a replacement for the first step in the existing procedure?
The "background section" you mentioned, would it be a preamble explaining the reason for the integration of FeatureA with FeatureB? Or would it serve a different purpose?
Do you have any specific format or points that you'd like to be covered in the background section?
Once we address these questions, I'll be able to provide a refined prompt that meets your requirements.

User:
1. I trust your skill to figure out the most reasonable approach
2. It is a section explaining why we are creating "Plan Of Change Documentation". Also how human does the comprehensive reasoning to make sure changes are complete, not just add, sometimes removal also possible
3. See point 2. But i think you have a profound knowledge how human does integration of another feature into another one. 

ChatGPT:
Thank you for the clarifications. Based on your answers, I'll proceed with the next steps.

Step 4: Plan Changes According to Requirements
Changes to be Made:

Incorporate a Background Section: We'll start the prompt with a background section explaining the rationale behind creating a "Plan Of Change" documentation. This will set the context for the users and explain why and how human engineers consider comprehensive reasoning during software feature integration.
Summarize High Relevance Items: Before diving deep into the analysis, we'll have a step where we identify and summarize the items of FeatureA that have a high relevance with FeatureB. This will streamline the analysis process and ensure we focus on the most pertinent items.
Responsibility Shift Consideration: In the analysis step, we'll incorporate considerations about responsibility shifts due to the development of new features. This will ensure the integration analysis is holistic and accounts for changes in feature functionalities for better modularity and understanding of requirements.
```
Please evaludate the output against the detailed steps defined. Please think step by step comprehensively about the problems you see.




[Evaludation Criterias]
[Context]
The criteria below are designed to evaluate the outputs of advanced language models like ChatGPT. Given the audience of the output will be large language models like ChatGPT, it's essential that the output is clear, structured, and logical.

[Criteria]
1. **Logical Sequence**: This criterion assesses the smooth transition of ideas from one to the next. It emphasizes both coherent intra-sentence structure and seamless inter-sentence connections.
2. **Organization and Structure**: This assesses the layout and arrangement of content. It places importance on the coherence of individual components as well as the overall flow of the text.
3. **Explicitness**: This gauges the clarity with which information is presented, ensuring that content is communicated unambiguously.
4. **Directness**: This measures the straightforwardness of the content, aiming to prevent unnecessary complexities in the writing.
5. **Succinctness**: Evaluates the brevity and conciseness of the content, ensuring that the model provides information without being overly verbose or repetitive.


5. Recommend changes to the original prompt based on your findings to ensure better outputs in future executions.


Version 2:
You are a "Prompt Evaluator". Your task is to identify where in the original prompt leads to unsatisfactory results from ChatGPT. After pinpointing the issues, you will plan improvements to enhance its clarity and explicitness, ensuring more desirable outcomes.

**Procedure**:
1. Understand the objectives and intent of the original prompt in the [OriginalPrompt] section.
2. Analyze the user feedback in the [Feedback] section against the output in the [Output] section, focusing on areas of dissatisfaction.
3. Use retrospective analysis like a human to determine which sentences in the original prompt could lead to dissatisfaction. Specifically, identify exact sections or sentences or phrases in the original prompt that are ambiguous or overly broad, leading to unsatisfactory results. Provide a direct link between these specific sentences and the issues observed in the output.
4. Based on your analysis, plan changes to improve the clarity and explicitness of the identified sections, sentences or phrases. Suggest concrete changes to enhance clarity and prevent misinterpretation.
5. Present the revised version based on change suggestions given in step 4.

**OutputFormat**:
- The output should strictly adhere to the original procedure's step names, formatting each step with the exact title as specified in the procedure, and ensuring the content under each step directly relates to its title without creating new titles or altering the original ones, thus maintaining clarity and consistency.
  Example:
  Step 1: Understand the objectives and intent of the original prompt in the `[OriginalPrompt]` section.
  {Elaborate on the analysis or action taken in this step, ensuring it aligns with the step's title.}


Follow the steps outlined in the `Procedure`. Take a deep breath, think step by step, and reason comprehensively for each step. The output should adhere to the defined output criteria from the `OutputFormat` section.


[OriginalPrompt]
$PromtStart$

As a senior requirement engineer, your task is to break down the user's requirements into smaller, logically incremental sub-requirements for analysis purposes only, for one existing Module Requirement Specification. Ensure that each sub-requirement is created, and they are internally incrementally organized.

**Context**
In software engineering, applications are divided into different modules. Over time, users might need to provide new requirements for the existing module requirements. `ModuleA` is an existing developed module in the application. It contains the detailed module requirement specifications. `NewUserRequirement` represents the new requirement given by the user. When the user's requirement involves multiple changes, it is essential to break down the user's requirement into individual incremental pieces for analysis. The focus should be on analyzing and breaking down these requirements, without delving into implementation strategies, code changes, or testing procedures.


**Procedure**
1. Review and summarize `ModuleA's` existing specifications from the `[ModuleRequirementSpecification]` section.
2. Understand the new requirements from the `[NewUserRequirement]` section. Engage the user in a Q&A session for the ambiguities.
3. **Analytically** break down the new requirements into incremental, manageable segments.
4. Present the final subdivided requirements pieces under `[IncrementalPiecies]` section.


**OutputFormat**:
- The output should strictly adhere to the original procedure's step objective, formatting each step with the exact title as specified in the procedure, and ensuring the content under each step directly relates to the step's purpose, thus maintaining clarity and consistency.
  Example:
  Step 1: Review and summarize `ModuleA's` existing specifications from the `[ModuleRequirementSpecification]` section.
  {Elaborate on the analysis or action taken in this step, ensuring it aligns with the step's title.}


Please follow the steps defined in the Procedure. Ensure meticulous step-by-step deep thinking and comprehensive reasoning for each step. The output should adhere to the defined output criteria from the `OutputFormat` section. If you do the analysis right, i will give you 200 dollars tips. 


[ModuleRequirementSpecification]
### Prompt Versioning Module Requirements Specification

#### 1. Module Description:
The prompt versioning module serves as a centralized prompt management system. It offers versioning for all the entities in the application that intend to have different versions of prompts for communication with a large language model. However, communication with the large language model is not handled within this module.

#### 2. Module Dependencies:
- **None**: This module operates independently and does not rely on other modules within the application.

#### 3. Symbols & Usage:
(Note: Since the example doesn't provide specific symbols, we are assuming generic ones based on the dependencies and usage.)
- **[â‡Œ Independent]**: Denotes functionalities or interactions that are managed internally without relying on other modules.

#### 4. Specifications:

4.1. **Functional Specifications**:
- **Single Effective Prompt per Entity**:
   - At any point, only one effective prompt is allowed for an entity.
   - Entity can designate any archived version as the current effective prompt, superseding the prior effective prompt.

- **Entity-Specific Default Prompt**:
   - Every entity or component that communicates with large language models should have a default prompt.
   - If prompts specific to an entity are absent in the database, the default prompt initializes the database as v1 and acts as the immediate effective prompt.

- **Dynamic Initialization of Versioned Prompts**:
   - Before any external system communication, the system retrieves the effective prompt for the respective entity from the database.
   - If a version for an entity is not in the database, the system uses the entity's default prompt for initialization.

- **Prompt Version Management**:
   - Entities can introduce a new prompt version upon modifying the existing prompt.
   - A maximum of 4 prompt versions are maintained for each entity.
   - If a new version exceeds the 4-version cap, the oldest version is purged.

- **Database Management**:
   - Versions are depicted using simple incremented integers.


[NewUserRequirement]
Actually its not prompt versioning. It's actually prompt template versioning. So i would like to rename "prompt" to "prompt template" in the Requirement Specification. So its more about renaming.

[IncrementalPiecies]
{Here you will put the broken-down piecies}
$PromptEnd$


[Feedback]
$start$
If you look at our second step from the original prompt 
```
2. Understand the new requirements from the `[NewUserRequirement]` section. Engage the user in a Q&A session for the ambiguities.
```

You will see that this step says engage user in a Q&A session if there are ambiguities. And in the output from ChatGPT, it does have phrases like the following 
```
The `NewUserRequirement` indicates a need for renaming within the module. The user specifies that the module should focus on "prompt template versioning" rather than just "prompt versioning." This requirement is primarily about renaming the term "prompt" to "prompt template" in the Requirement Specification to better reflect the module's purpose and functionality.

Before proceeding, it would be beneficial to clarify with the user if this renaming affects only the terminology in the documentation or if it also impacts any naming conventions within the codebase or the database schema. Understanding the scope of this change is crucial for a precise breakdown.
```

However, the output does not wait for user's answer, it continues to Step 3 directly.
$end$

[Output]
$start$
### Step 1: Review and summarize `ModuleA's` existing specifications from the `[ModuleRequirementSpecification]` section.

In the current `ModuleRequirementSpecification` for `ModuleA`, which is focused on a Prompt Versioning Module, several key aspects are outlined:

1. **Module Description**: This module acts as a centralized prompt management system, offering versioning capabilities for various entities within the application that need different versions of prompts for communication with a large language model. However, the module does not handle communication with the large language model itself.

2. **Module Dependencies**: The module is designed to be independent and does not rely on other modules within the application.

3. **Symbols & Usage**: The symbol `[â‡Œ Independent]` is used to denote functionalities or interactions managed internally without dependency on other modules.

4. **Functional Specifications**:
   - **Single Effective Prompt per Entity**: Only one active prompt is allowed per entity at any time. Entities can switch their active prompt by designating any archived version as the current effective prompt.
   - **Entity-Specific Default Prompt**: Each entity must have a default prompt, which is used if no specific prompts are available for that entity.
   - **Dynamic Initialization of Versioned Prompts**: The system retrieves the effective prompt for an entity before any external system communication. If no version exists, the entity's default prompt is used.
   - **Prompt Version Management**: Entities can create new prompt versions, with a maximum of 4 versions maintained. Exceeding this limit results in the oldest version being purged.
   - **Database Management**: Prompt versions are tracked using simple incremented integers.

### Step 2: Understand the new requirements from the `[NewUserRequirement]` section. Engage the user in a Q&A session for the ambiguities.

The `NewUserRequirement` indicates a need for renaming within the module. The user specifies that the module should focus on "prompt template versioning" rather than just "prompt versioning." This requirement is primarily about renaming the term "prompt" to "prompt template" in the Requirement Specification to better reflect the module's purpose and functionality.

Before proceeding, it would be beneficial to clarify with the user if this renaming affects only the terminology in the documentation or if it also impacts any naming conventions within the codebase or the database schema. Understanding the scope of this change is crucial for a precise breakdown.

### Step 3: Analytically break down the new requirements into incremental, manageable segments.

Given the user's requirement to rename "prompt" to "prompt template," the breakdown can be as follows:

1. **Terminology Update in Documentation**: 
   - Replace all instances of "prompt" with "prompt template" in the Requirement Specification document. This includes headings, descriptions, and any references within the text.

2. **Codebase Assessment** (If applicable based on user clarification):
   - Analyze the impact of this renaming on the codebase. Identify all instances where "prompt" is used in the code, including variable names, function names, comments, and documentation within the code.

3. **Database Schema Update** (If applicable):
   - Review the database schema to identify if the term "prompt" is used in any table names, column names, or stored procedures. Plan for the necessary changes to rename these to incorporate "prompt template."

4. **Impact Analysis on Dependent Features**:
   - Evaluate how this change might affect any features or modules that interact with the Prompt Versioning Module. This includes checking for dependencies that might require updates due to the renaming.

5. **Versioning and Archiving Strategy**:
   - Decide on a strategy for versioning the updated documentation and potentially the codebase and database schema changes. This includes maintaining a clear record of changes for audit and rollback purposes.

### Step 4: Present the final subdivided requirements pieces under `[IncrementalPiecies]` section.

[IncrementalPiecies]

1. **Documentation Update**: 
   - Replace "prompt" with "prompt template" in all instances within the Module Requirement Specification.

2. **Codebase Review and Update** (Conditional):
   - Identify and update all occurrences of "prompt" in the codebase to "prompt template."

3. **Database Schema Modification** (Conditional):
   - Alter any database elements named "prompt" to "prompt template."

4. **Dependent Feature Analysis**:
   - Conduct a thorough analysis of any dependent features or modules to identify necessary updates.

5. **Versioning and Archiving**:
   - Implement a versioning strategy for the documentation, code, and database changes, ensuring clear documentation of all modifications for future reference.
$end$



