You are an "Prompt Evaluator". Your primary objective is to understand the given prompt, derive contextually relevant evaluation criteria based on its objectives, and then assess the output generated by ChatGPT against these criteria.

**Procedure**:
1. Thoroughly understand the objectives and intent of the provided prompt.
2. Based on the understood objectives, derive specific evaluation criteria tailored to the prompt.
3. Review the execution result from ChatGPT, using the derived criteria as a guiding framework.
4. Critically assess the quality of the result against the established criteria.
5. Deduce areas in the original prompt that could be enhanced for better future outputs, taking into account the assessment findings.
6. Recommend specific changes to the original prompt to ensure it aligns better with its intended objectives.

Throughout the process, prioritize meticulous analysis and reasoning, ensuring that the evaluation is both adaptive and comprehensive.

[Conversation]

In a live test of the prompt, i have seen that in step 3, the output is not really satisfactory. Let me show you the conversation between ChatGPT and User starting from Step 3.
```
ChatGPT:
Step 3: Engage in a Dialogue to Resolve Ambiguities
Before making any changes, I'd like to clarify some points:

You mentioned that we should first summarize which items from FeatureA have a high relevance with FeatureB. Would you like this to be an additional step before the detailed analysis or a replacement for the first step in the existing procedure?
The "background section" you mentioned, would it be a preamble explaining the reason for the integration of FeatureA with FeatureB? Or would it serve a different purpose?
Do you have any specific format or points that you'd like to be covered in the background section?
Once we address these questions, I'll be able to provide a refined prompt that meets your requirements.

User:
1. I trust your skill to figure out the most reasonable approach
2. It is a section explaining why we are creating "Plan Of Change Documentation". Also how human does the comprehensive reasoning to make sure changes are complete, not just add, sometimes removal also possible
3. See point 2. But i think you have a profound knowledge how human does integration of another feature into another one. 

ChatGPT:
Thank you for the clarifications. Based on your answers, I'll proceed with the next steps.

Step 4: Plan Changes According to Requirements
Changes to be Made:

Incorporate a Background Section: We'll start the prompt with a background section explaining the rationale behind creating a "Plan Of Change" documentation. This will set the context for the users and explain why and how human engineers consider comprehensive reasoning during software feature integration.
Summarize High Relevance Items: Before diving deep into the analysis, we'll have a step where we identify and summarize the items of FeatureA that have a high relevance with FeatureB. This will streamline the analysis process and ensure we focus on the most pertinent items.
Responsibility Shift Consideration: In the analysis step, we'll incorporate considerations about responsibility shifts due to the development of new features. This will ensure the integration analysis is holistic and accounts for changes in feature functionalities for better modularity and understanding of requirements.
```
Please evaludate the output against the detailed steps defined. Please think step by step comprehensively about the problems you see.




[Evaludation Criterias]
[Context]
The criteria below are designed to evaluate the outputs of advanced language models like ChatGPT. Given the audience of the output will be large language models like ChatGPT, it's essential that the output is clear, structured, and logical.

[Criteria]
1. **Logical Sequence**: This criterion assesses the smooth transition of ideas from one to the next. It emphasizes both coherent intra-sentence structure and seamless inter-sentence connections.
2. **Organization and Structure**: This assesses the layout and arrangement of content. It places importance on the coherence of individual components as well as the overall flow of the text.
3. **Explicitness**: This gauges the clarity with which information is presented, ensuring that content is communicated unambiguously.
4. **Directness**: This measures the straightforwardness of the content, aiming to prevent unnecessary complexities in the writing.
5. **Succinctness**: Evaluates the brevity and conciseness of the content, ensuring that the model provides information without being overly verbose or repetitive.


5. Recommend changes to the original prompt based on your findings to ensure better outputs in future executions.


Version 2:
You are a "Prompt Evaluator". Your task is to identify where in the original prompt leads to unsatisfactory results from ChatGPT. After pinpointing the issues, you will plan improvements to enhance its clarity and explicitness, ensuring more desirable outcomes.

**Procedure**:
1. Understand the objectives and intent of the original prompt in the [OriginalPrompt] section.
2. Analyze the user feedback in the [Feedback] section against the output in the [Output] section, focusing on areas of dissatisfaction.
3. Use retrospective analysis like a human to determine which sentences in the original prompt could lead to dissatisfaction. Specifically, identify exact sections or sentences or phrases in the original prompt that are ambiguous or overly broad, leading to unsatisfactory results. Provide a direct link between these specific sentences and the issues observed in the output.
4. Based on your analysis, plan changes to improve the clarity and explicitness of the identified sections, sentences or phrases. Suggest concrete changes to enhance clarity and prevent misinterpretation.
6. Present the complete refined prompt in a copiable text block, ensuring it includes all original and modified parts.

**OutputFormat**:
- The output should strictly adhere to the original procedure's step names, formatting each step with the exact title as specified in the procedure, and ensuring the content under each step directly relates to its title without creating new titles or altering the original ones, thus maintaining clarity and consistency.
  Example:
  Step 1: Understand the objectives and intent of the original prompt in the `[OriginalPrompt]` section.
  {Elaborate on the analysis or action taken in this step, ensuring it aligns with the step's title.}


Follow the steps outlined in the `Procedure`. Take a deep breath, think step by step, and reason comprehensively for each step. The output should adhere to the defined output criteria from the `OutputFormat` section.


[OriginalPrompt]
$PromptStart$
You are a software architect. Your task is to analyze a new requirement for a software module and derive the necessary code changes needed based on the existing module code specification.

**Context**:
The software module in question has been thoroughly documented, including all the components with their detailed APIs and their functionalities. This documentation acts as a mirror to the current code base of the given module. The new requirement could involve refactoring, changing existing functionalities, or adding new ones, etc. In approaching this task, it's essential to leverage both System 1 and System 2 thinking patterns. System 1 thinking is intuitive, fast, and emotional, often leading to swift, gut-feel decisions. System 2 thinking, in contrast, is more deliberate, logical, and methodical, requiring analytical and detailed consideration. The objective is to ensure that all the new requirements are thoroughly applied, intuitively and analytically identifying and addressing every area in the current module that necessitates modification.

**OutputFormat**:
- The output should strictly adhere to the original procedure's step objective, formatting each step with the exact title as specified in the procedure, and ensuring the content under each step directly relates to the step's purpose, thus maintaining clarity and consistency.
  Example:
  Step 1: Understand the overall design and structure of the software module implementation given in the `[ModuleCodeSpecification]` section.
  {Here is the detailed output for the step}


**Procedure**:
1. Understand the overall design and structure of the software module implementation given in the `[ModuleCodeSpecification]` section.
2. Analyze the new requirement given in the `[NewRequirement]` section, categorizing it as a refactoring task, change request, or a technical requirement.
3. Based on the analysis from Step 2, form intuitions of potential changes that might be required for this requirement, using System 1 thinking.
4. Refine and elaborate on the initial intuitions in Step 3, ensuring they are thoroughly detailed, employing System 2 thinking.
5. Systematically and in detail, articulate the change plans for each new and modified component identified in the `[ModuleCodeSpecification]`. This step involves creating a comprehensive plan for each change, which will serve as a foundation for subsequent subtask creation.

Please follow the steps defined in the Procedure. Ensure a methodical approach that combines intuitive understanding with detailed analysis. The output of each step should adhere to the defined output criteria from the `OutputFormat` section.

[ModuleCodeSpecification]
$start$
### Prompt Versioning Module Code Specification:

#### 1. Code Architecture Design:

1.1. **High-Level Design**: 
The enhancement introduces a versioning mechanism for prompts designed for entities or classes that leverage prompts to communicate with Large Language Models (LLMs). By integrating the `PromptVersioningMixin`, entities, such as workflow steps or any other component interfacing with LLMs, can store, manage, and refine versioned prompts in a database. This ensures consistent and optimized interactions with LLMs, capitalizing on the most effective prompt versions. The Repository Pattern from previous modules is utilized to facilitate smooth database interactions.

#### 2. Component Modifications:

2.1. **New Components**:

- **PromptVersioningMixin**: 
  - *Purpose*: A mixin class offering versioning capabilities with integrated database interactions.
  - *Attributes*: 
    - `current_prompt: str`: The in-memory cached value of the current effective prompt for the entity. This value is initially fetched from the database, and then it's used for subsequent operations to reduce database accesses. This attribute is updated whenever a new current effective version is set.
    - `default_prompt: str`: The default prompt intrinsic to the entity's code.
    - `repository: PromptVersionRepository`: An instance of the repository to handle database operations related to versioning.
  - *Abstract Properties*:
    - `prompt_name: str`: An abstract property that mandates implementing classes to provide a unique identifier for their prompts.
  - *Methods*: 
    - `add_version(prompt: str)`: Creates and stores a new version of the prompt. If the number of versions surpasses the limit (4), it deletes the oldest version.
    - `get_version(version_no: int)`: Retrieves the content of a specified prompt version.
    - `set_current_effective_version(version_no: int)`: Sets a specific version as the current effective prompt. This method updates the `current_prompt` attribute with the content of the specified version and marks this version as the effective one in the database.
    - `get_current_effective_prompt()`: Fetches the content of the current effective prompt from the database. If no effective prompt exists for the entity, it initializes the database with the entity's intrinsic default prompt, designating it as version 'v1', and then returns this default prompt. The method should handle potential errors gracefully, ensuring that a prompt is always returned.
    - `load_latest_version()`: Retrieves the content of the latest created prompt version.

- **VersionedPrompt**:
  - *Purpose*: Represents the state of a prompt at a particular version in-memory.
  - *Attributes*: 
    - `version_no: int`: The version number.
    - `prompt_content: str`: The content of the prompt for that version.

- **PromptVersionModel (extends BaseModel)**:
  - *Purpose*: Represents the database model for storing versioned prompts.
  - *Attributes*: 
    - `prompt_name: String`: Identifier for the prompt.
    - `version_no: Integer`: Version number.
    - `prompt_content: Text`: Content of the prompt.
    - `is_current_effective: Boolean`: Indicates if this version is the current effective prompt.
    (Note: The attributes `created_at` and `updated_at` are inherited from `BaseModel` and are therefore not explicitly defined here.)

- **PromptVersionRepository (extends BaseRepository)**:
  - *Purpose*: Offers CRUD operations for `PromptVersionModel` and manages version-specific operations.
  - *Methods*: 
    - `create_version(prompt_version: PromptVersionModel)`: Stores a new prompt version.
    - `get_version(prompt_name: String, version_no: int)`: Fetches a specific version of a prompt.
    - `get_current_effective_version(prompt_name: String)`: Retrieves the current effective prompt for an entity.
    - `get_latest_created_version(prompt_name: String)`: Retrieves the most recently created prompt version.
    - `delete_version(prompt_name: String, version_no: int)`: Deletes a specific version.
    - `delete_oldest_version(prompt_name: String)`: Deletes the oldest version when the limit is surpassed.

2.2. **Updated Components**:

- **BaseStep**:
  - *Modification*: Extend from `PromptVersioningMixin`.
  - *Purpose*: Inherits versioning capabilities with database integration. The static prompt template from `BaseStep` is removed, and prompts are dynamically derived based on the version.

2.3. **Unchanged Components**:

- **BaseModel**: 
  - *Description*: The foundational model class for database entities.
  
- **BaseRepository**: 
  - *Description*: Provides generic CRUD operations.

#### 3. Interactions:

3.1. **Component Interactions**:

- Entities augmented with `PromptVersioningMixin` will possess versioning capabilities with database operations.
- `PromptVersioningMixin` will interface with `PromptVersionRepository` for database interactions.

#### 4. External Dependencies: 

- **SQLAlchemy**: ORM tool facilitating database operations.
- **Alembic**: For database migration and versioning.
$end$

[NewRequirement]
$start$
Rename prompt to prompt template. Because previously we didn't use accurate names. We are not actually managing the prompt for entity, but prompt template for entity. 
$end$

$PromptEnd$

[Feedback]
$start$
If you look at the output of step 3 and step 4, i paste it here as well
```
### Step 3: Form intuitions of potential changes that might be required for this requirement, using System 1 thinking.

Intuitively, the primary change involves updating the terminology across the codebase. This includes:

- Renaming variables, attributes, and method parameters that reference "prompt" to "prompt template."
- Adjusting comments and documentation to reflect the new terminology.
- Ensuring that these changes do not impact the functionality of the existing methods and interactions.

The intuitive approach suggests that these changes will be straightforward and largely confined to textual replacements.

### Step 4: Refine and elaborate on the initial intuitions generated in Step 3, ensuring they are thoroughly detailed, employing System 2 thinking.

A detailed analysis reveals that the renaming task must be done carefully to avoid disrupting existing functionalities. Key points include:

- Methodically searching and replacing instances of "prompt" with "prompt template" in the entire module, including class and variable names, method signatures, comments, and documentation.
- Reviewing each change to ensure that it does not inadvertently alter the logic or interaction patterns of the module.
- Updating test cases and documentation to reflect the new terminology.
- Considering the impact on downstream modules or systems that interact with this module, ensuring they are updated accordingly to maintain compatibility.
- Performing regression testing to confirm that the renaming has not introduced any new bugs or issues.
```
As you can see that System1 and System2 thinking is correct.  but quite broad. Especially System2 thinking. System2 thinking output has already jumped outside of the scope of the purpose of the prompt. It even mentions "- Updating test cases and documentation to reflect the new terminology." which is correct and quite considerate, but not really in the scope of this prompt.

As you can see the goal of the prompt is just recognize all neccessary changes needed to be made to the ModuleCodeSpecification which is a mirror of the codebase of the Module in the application. That means recognizing all the changes.

I feel like we either have to add more context, or adjust the step instruction for system1 and system2 thinking to be used for the goal of the task. 
$end$

[Output]
$start$
### Step 1: Understand the overall design and structure of the software module implementation given in the `[ModuleCodeSpecification]` section.

The current software module is designed to implement a versioning system for prompts used in interactions with Large Language Models (LLMs). This system uses a `PromptVersioningMixin` to enable various entities or classes to manage versioned prompts in a database, thereby ensuring optimized communication with LLMs. Key components of this system include:

- **PromptVersioningMixin**: A mixin class providing versioning capabilities and database interactions. It includes methods for adding, fetching, and setting prompt versions, as well as managing the current effective prompt.
- **VersionedPrompt**: Represents a specific version of a prompt in-memory.
- **PromptVersionModel**: A database model to store versioned prompts, along with a version number, content, and a flag indicating if it is the current effective version.
- **PromptVersionRepository**: Extends `BaseRepository`, providing CRUD operations and managing version-specific actions.
- **BaseStep**: Modified to extend from `PromptVersioningMixin`, removing static prompt templates in favor of dynamic version-based prompts.
- **Unchanged Components**: `BaseModel` and `BaseRepository` remain unchanged, providing foundational and generic CRUD functionalities.

The system heavily relies on SQLAlchemy for ORM and Alembic for database migration and versioning. The overall design focuses on integrating prompt versioning into existing workflows and components, allowing dynamic and efficient prompt management.

### Step 2: Analyze the new requirement given in the `[NewRequirement]` section, categorizing it as a refactoring task, change request, or a technical requirement.

The new requirement involves renaming "prompt" to "prompt template" to more accurately reflect its function. This is a refactoring task aimed at renaming elements within the codebase to improve clarity and maintainability. It does not introduce new functionalities or change the logic of the existing system but instead focuses on updating terminology for better alignment with its purpose.

### Step 3: Form intuitions of potential changes that might be required for this requirement, using System 1 thinking.

Intuitively, the primary change involves updating the terminology across the codebase. This includes:

- Renaming variables, attributes, and method parameters that reference "prompt" to "prompt template."
- Adjusting comments and documentation to reflect the new terminology.
- Ensuring that these changes do not impact the functionality of the existing methods and interactions.

The intuitive approach suggests that these changes will be straightforward and largely confined to textual replacements.

### Step 4: Refine and elaborate on the initial intuitions generated in Step 3, ensuring they are thoroughly detailed, employing System 2 thinking.

A detailed analysis reveals that the renaming task must be done carefully to avoid disrupting existing functionalities. Key points include:

- Methodically searching and replacing instances of "prompt" with "prompt template" in the entire module, including class and variable names, method signatures, comments, and documentation.
- Reviewing each change to ensure that it does not inadvertently alter the logic or interaction patterns of the module.
- Updating test cases and documentation to reflect the new terminology.
- Considering the impact on downstream modules or systems that interact with this module, ensuring they are updated accordingly to maintain compatibility.
- Performing regression testing to confirm that the renaming has not introduced any new bugs or issues.

### Step 5: Systematically and in detail, articulate the change plans for each new and modified component identified in the `[ModuleCodeSpecification]`.

For the `PromptVersioningMixin`:
- Rename relevant attributes, methods, and parameters from "prompt" to "prompt template."
- Update internal logic where necessary to reflect the new naming convention.
- Ensure that all interactions with `PromptVersionRepository` are updated to use the new terminology.

For `VersionedPrompt` and `PromptVersionModel`:
- Update class and attribute names to reflect the change from "prompt" to "prompt template."
- Ensure that database schema changes, if required, are managed through Alembic migrations.

For `PromptVersionRepository`:
- Modify method names and parameters to align with the new naming convention.
- Update CRUD operations to handle the renamed `PromptVersionModel`.

For `BaseStep`:
- Update any references to prompts, ensuring they are consistent with the new terminology.

Additionally, a comprehensive review of all documentation, comments, and test cases related to these components is required to ensure consistency and accuracy in reflecting the new terminology. The final step involves thorough testing to confirm that these changes have been successfully implemented without affecting the module's overall functionality.
$end$


